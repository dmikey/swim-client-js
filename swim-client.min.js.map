{"version":3,"sources":["node_modules/browser-pack/_prelude.js","config.json","swim-client.min.js","node_modules/swim-proto-js/config.json","node_modules/swim-proto-js/swim-proto.js","swim-client.js"],"names":["f","exports","module","define","amd","g","window","global","self","this","swim","client","e","t","n","r","s","o","u","a","require","i","Error","code","l","call","length",1,"version","SEND_BUFFER_SIZE","MAX_RECONNECT_TIME",2,3,4,"decode","record","recon","tag","EventMessage","CommandMessage","SyncRequest","SyncedResponse","LinkRequest","LinkedResponse","UnlinkRequest","UnlinkedResponse","encode","envelope","parse","string","stringify","Envelope","RequestEnvelope","ResponseEnvelope","MessageEnvelope","node","lane","via","body","prio","config","Object","defineProperty","prototype","value","create","constructor","headers","push","concat","@event","tail","head","header","undefined","@command","@sync","@synced","@link","@linked","@unlink","@unlinked","./config.json","recon-js","swim-client-js","auth","query","Channel","sync","handle","get","link","proxySync","proxy","proxyLink","unlink","sendEvent","sendCommand","reset","endpoint","bridge","channel","sendBuffer","unlinkAll","close","linkCount","linkHandles","reconnectTimeout","reconnectTime","Math","round","random","closed","open","proto","WebSocket","w3cwebsocket","LINK_FAILED","LINK_BROKEN","LINK_WANTED","LINK_ACTIVE","requestUri","socket","onopen","onOpen","bind","onclose","onClose","onmessage","onFrame","onerror","onError","send","readyState","OPEN","buffer","isSyncRequest","isLinkRequest","isUnlinkRequest","clearTimeout","nodeHandles","laneHandles","synced","state","__swim_link_state__","unresolve","shift","status","onBroken","setTimeout","min","frame","payload","data","onReceive","initHandle","onEvent","onCommand","configurable","registerHandle","unlinked","unregisterHandle","index","Function","indexOf","splice","keys","request","onLinked","onFailed","message","isEventMessage","onMessage","isCommandMessage","isSyncedResponse","onSynced","isLinkedResponse","isUnlinkedResponse","onUnlinked","uri","resolve","parentLane","onUnbroken","components","scheme","authority","path","fragment","slice","swim-proto-js","websocket"],"mappings":"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","file":"swim-client.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","module.exports={\"version\":\"0.3.0\",\"SEND_BUFFER_SIZE\":1024,\"MAX_RECONNECT_TIME\":15000}","(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}(g.swim || (g.swim = {})).client = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\nmodule.exports={\"version\":\"0.3.0\",\"SEND_BUFFER_SIZE\":1024,\"MAX_RECONNECT_TIME\":15000}\n},{}],2:[function(require,module,exports){\n\n},{}],3:[function(require,module,exports){\nmodule.exports={\"version\":\"0.3.0\"}\n},{}],4:[function(require,module,exports){\n'use strict';\n\nvar config = require('./config.json');\nvar recon = require('recon-js');\n\nfunction decode(record) {\n  switch (recon.tag(record)) {\n    case '@event': return EventMessage.decode(record);\n    case '@command': return CommandMessage.decode(record);\n    case '@sync': return SyncRequest.decode(record);\n    case '@synced': return SyncedResponse.decode(record);\n    case '@link': return LinkRequest.decode(record);\n    case '@linked': return LinkedResponse.decode(record);\n    case '@unlink': return UnlinkRequest.decode(record);\n    case '@unlinked': return UnlinkedResponse.decode(record);\n  }\n}\n\nfunction encode(envelope) {\n  return envelope.encode();\n}\n\nfunction parse(string) {\n  return decode(recon.parse(string));\n}\n\nfunction stringify(envelope) {\n  return recon.stringify(encode(envelope));\n}\n\n\nfunction Envelope() {}\nObject.defineProperty(Envelope.prototype, 'isRequest', {value: false});\nObject.defineProperty(Envelope.prototype, 'isResponse', {value: false});\nObject.defineProperty(Envelope.prototype, 'isMessage', {value: false});\nObject.defineProperty(Envelope.prototype, 'isEventMessage', {value: false});\nObject.defineProperty(Envelope.prototype, 'isCommandMessage', {value: false});\nObject.defineProperty(Envelope.prototype, 'isSyncRequest', {value: false});\nObject.defineProperty(Envelope.prototype, 'isSyncedResponse', {value: false});\nObject.defineProperty(Envelope.prototype, 'isLinkRequest', {value: false});\nObject.defineProperty(Envelope.prototype, 'isLinkedResponse', {value: false});\nObject.defineProperty(Envelope.prototype, 'isUnlinkRequest', {value: false});\nObject.defineProperty(Envelope.prototype, 'isUnlinkedResponse', {value: false});\n\n\nfunction RequestEnvelope() {\n  Envelope.call(this);\n}\nRequestEnvelope.prototype = Object.create(Envelope.prototype);\nRequestEnvelope.prototype.constructor = RequestEnvelope;\nObject.defineProperty(RequestEnvelope.prototype, 'isRequest', {value: true});\n\n\nfunction ResponseEnvelope() {\n  Envelope.call(this);\n}\nResponseEnvelope.prototype = Object.create(Envelope.prototype);\nResponseEnvelope.prototype.constructor = ResponseEnvelope;\nObject.defineProperty(RequestEnvelope.prototype, 'isResponse', {value: true});\n\n\nfunction MessageEnvelope() {\n  Envelope.call(this);\n}\nMessageEnvelope.prototype = Object.create(Envelope.prototype);\nMessageEnvelope.prototype.constructor = MessageEnvelope;\nObject.defineProperty(RequestEnvelope.prototype, 'isMessage', {value: true});\n\n\nfunction EventMessage(node, lane, via, body) {\n  MessageEnvelope.call(this);\n  this.node = node;\n  this.lane = lane;\n  this.via = via;\n  this.body = body;\n}\nEventMessage.prototype = Object.create(MessageEnvelope.prototype);\nEventMessage.prototype.constructor = EventMessage;\nObject.defineProperty(EventMessage.prototype, 'isEventMessage', {value: true});\nEventMessage.prototype.encode = function () {\n  var headers = [{node: this.node}, {lane: this.lane}];\n  if (this.via) headers.push({via: this.via});\n  return recon.concat({'@event': headers}, this.body);\n};\nEventMessage.decode = function (record) {\n  var node, lane, via;\n  var body = recon.tail(record);\n  var headers = recon.head(record);\n  var n = headers && headers.length || 0;\n  for (var i = 0; i < n; i += 1) {\n    var header = headers[i];\n    if (header.node !== undefined) node = header.node;\n    else if (header.lane !== undefined) lane = header.lane;\n    else if (header.via !== undefined) via = header.via;\n    else if (i === 0) node = header;\n    else if (i === 1) lane = header;\n    else if (i === 2) via = header;\n  }\n  if (node !== undefined && lane !== undefined) {\n    return new EventMessage(node, lane, via, body);\n  }\n};\n\n\nfunction CommandMessage(node, lane, via, body) {\n  MessageEnvelope.call(this);\n  this.node = node;\n  this.lane = lane;\n  this.via = via;\n  this.body = body;\n}\nCommandMessage.prototype = Object.create(MessageEnvelope.prototype);\nCommandMessage.prototype.constructor = CommandMessage;\nObject.defineProperty(CommandMessage.prototype, 'isCommandMessage', {value: true});\nCommandMessage.prototype.encode = function () {\n  var headers = [{node: this.node}, {lane: this.lane}];\n  if (this.via) headers.push({via: this.via});\n  return recon.concat({'@command': headers}, this.body);\n};\nCommandMessage.decode = function (record) {\n  var node, lane, via;\n  var body = recon.tail(record);\n  var headers = recon.head(record);\n  var n = headers && headers.length || 0;\n  for (var i = 0; i < n; i += 1) {\n    var header = headers[i];\n    if (header.node !== undefined) node = header.node;\n    else if (header.lane !== undefined) lane = header.lane;\n    else if (header.via !== undefined) via = header.via;\n    else if (i === 0) node = header;\n    else if (i === 1) lane = header;\n    else if (i === 2) via = header;\n  }\n  if (node !== undefined && lane !== undefined) {\n    return new CommandMessage(node, lane, via, body);\n  }\n};\n\n\nfunction SyncRequest(node, lane, prio) {\n  RequestEnvelope.call(this);\n  this.node = node;\n  this.lane = lane;\n  this.prio = prio || 0.0;\n}\nSyncRequest.prototype = Object.create(RequestEnvelope.prototype);\nSyncRequest.prototype.constructor = SyncRequest;\nObject.defineProperty(SyncRequest.prototype, 'isSyncRequest', {value: true});\nSyncRequest.prototype.encode = function () {\n  var headers = [{node: this.node}, {lane: this.lane}];\n  if (this.prio) headers.push({prio: this.prio});\n  return recon({'@sync': headers});\n};\nSyncRequest.decode = function (record) {\n  var node, lane, prio;\n  var headers = recon.head(record);\n  var n = headers && headers.length || 0;\n  for (var i = 0; i < n; i += 1) {\n    var header = headers[i];\n    if (header.node !== undefined) node = header.node;\n    else if (header.lane !== undefined) lane = header.lane;\n    else if (header.prio !== undefined) prio = header.prio;\n    else if (i === 0) node = header;\n    else if (i === 1) lane = header;\n  }\n  if (node !== undefined && lane !== undefined) {\n    return new SyncRequest(node, lane, prio);\n  }\n};\n\n\nfunction SyncedResponse(node, lane) {\n  ResponseEnvelope.call(this);\n  this.node = node;\n  this.lane = lane;\n}\nSyncedResponse.prototype = Object.create(ResponseEnvelope.prototype);\nSyncedResponse.prototype.constructor = SyncedResponse;\nObject.defineProperty(SyncedResponse.prototype, 'isSyncedResponse', {value: true});\nSyncedResponse.prototype.encode = function () {\n  var headers = [{node: this.node}, {lane: this.lane}];\n  return recon({'@synced': headers});\n};\nSyncedResponse.decode = function (record) {\n  var node, lane;\n  var headers = recon.head(record);\n  var n = headers && headers.length || 0;\n  for (var i = 0; i < n; i += 1) {\n    var header = headers[i];\n    if (header.node !== undefined) node = header.node;\n    else if (header.lane !== undefined) lane = header.lane;\n    else if (i === 0) node = header;\n    else if (i === 1) lane = header;\n  }\n  if (node !== undefined && lane !== undefined) {\n    return new SyncedResponse(node, lane);\n  }\n};\n\n\nfunction LinkRequest(node, lane, prio) {\n  RequestEnvelope.call(this);\n  this.node = node;\n  this.lane = lane;\n  this.prio = prio || 0.0;\n}\nLinkRequest.prototype = Object.create(RequestEnvelope.prototype);\nLinkRequest.prototype.constructor = LinkRequest;\nObject.defineProperty(LinkRequest.prototype, 'isLinkRequest', {value: true});\nLinkRequest.prototype.encode = function () {\n  var headers = [{node: this.node}, {lane: this.lane}];\n  if (this.prio) headers.push({prio: this.prio});\n  return recon({'@link': headers});\n};\nLinkRequest.decode = function (record) {\n  var node, lane, prio;\n  var headers = recon.head(record);\n  var n = headers && headers.length || 0;\n  for (var i = 0; i < n; i += 1) {\n    var header = headers[i];\n    if (header.node !== undefined) node = header.node;\n    else if (header.lane !== undefined) lane = header.lane;\n    else if (header.prio !== undefined) prio = header.prio;\n    else if (i === 0) node = header;\n    else if (i === 1) lane = header;\n  }\n  if (node !== undefined && lane !== undefined) {\n    return new LinkRequest(node, lane, prio);\n  }\n};\n\n\nfunction LinkedResponse(node, lane, prio) {\n  ResponseEnvelope.call(this);\n  this.node = node;\n  this.lane = lane;\n  this.prio = prio || 0.0;\n}\nLinkedResponse.prototype = Object.create(ResponseEnvelope.prototype);\nLinkedResponse.prototype.constructor = LinkedResponse;\nObject.defineProperty(LinkedResponse.prototype, 'isLinkedResponse', {value: true});\nLinkedResponse.prototype.encode = function () {\n  var headers = [{node: this.node}, {lane: this.lane}];\n  if (this.prio) headers.push({prio: this.prio});\n  return recon({'@linked': headers});\n};\nLinkedResponse.decode = function (record) {\n  var node, lane, prio;\n  var headers = recon.head(record);\n  var n = headers && headers.length || 0;\n  for (var i = 0; i < n; i += 1) {\n    var header = headers[i];\n    if (header.node !== undefined) node = header.node;\n    else if (header.lane !== undefined) lane = header.lane;\n    else if (header.prio !== undefined) prio = header.prio;\n    else if (i === 0) node = header;\n    else if (i === 1) lane = header;\n  }\n  if (node !== undefined && lane !== undefined) {\n    return new LinkedResponse(node, lane, prio);\n  }\n};\n\n\nfunction UnlinkRequest(node, lane) {\n  RequestEnvelope.call(this);\n  this.node = node;\n  this.lane = lane;\n}\nUnlinkRequest.prototype = Object.create(RequestEnvelope.prototype);\nUnlinkRequest.prototype.constructor = UnlinkRequest;\nObject.defineProperty(UnlinkRequest.prototype, 'isUnlinkRequest', {value: true});\nUnlinkRequest.prototype.encode = function () {\n  var headers = [{node: this.node}, {lane: this.lane}];\n  return recon({'@unlink': headers});\n};\nUnlinkRequest.decode = function (record) {\n  var node, lane;\n  var headers = recon.head(record);\n  var n = headers && headers.length || 0;\n  for (var i = 0; i < n; i += 1) {\n    var header = headers[i];\n    if (header.node !== undefined) node = header.node;\n    else if (header.lane !== undefined) lane = header.lane;\n    else if (i === 0) node = header;\n    else if (i === 1) lane = header;\n  }\n  if (node !== undefined && lane !== undefined) {\n    return new UnlinkRequest(node, lane);\n  }\n};\n\n\nfunction UnlinkedResponse(node, lane) {\n  ResponseEnvelope.call(this);\n  this.node = node;\n  this.lane = lane;\n}\nUnlinkedResponse.prototype = Object.create(ResponseEnvelope.prototype);\nUnlinkedResponse.prototype.constructor = UnlinkedResponse;\nObject.defineProperty(UnlinkedResponse.prototype, 'isUnlinkedResponse', {value: true});\nUnlinkedResponse.prototype.encode = function () {\n  var headers = [{node: this.node}, {lane: this.lane}];\n  return recon({'@unlinked': headers});\n};\nUnlinkedResponse.decode = function (record) {\n  var node, lane;\n  var headers = recon.head(record);\n  var n = headers && headers.length || 0;\n  for (var i = 0; i < n; i += 1) {\n    var header = headers[i];\n    if (header.node !== undefined) node = header.node;\n    else if (header.lane !== undefined) lane = header.lane;\n    else if (i === 0) node = header;\n    else if (i === 1) lane = header;\n  }\n  if (node !== undefined && lane !== undefined) {\n    return new UnlinkedResponse(node, lane);\n  }\n};\n\n\nexports.decode = decode;\nexports.encode = encode;\nexports.parse = parse;\nexports.stringify = stringify;\nexports.Envelope = Envelope;\nexports.RequestEnvelope = RequestEnvelope;\nexports.ResponseEnvelope = ResponseEnvelope;\nexports.MessageEnvelope = MessageEnvelope;\nexports.EventMessage = EventMessage;\nexports.CommandMessage = CommandMessage;\nexports.SyncRequest = SyncRequest;\nexports.SyncedResponse = SyncedResponse;\nexports.LinkRequest = LinkRequest;\nexports.LinkedResponse = LinkedResponse;\nexports.UnlinkRequest = UnlinkRequest;\nexports.UnlinkedResponse = UnlinkedResponse;\nexports.config = config;\n\n},{\"./config.json\":3,\"recon-js\":\"recon-js\"}],\"swim-client-js\":[function(require,module,exports){\n(function (global){\n'use strict';\n\nvar config = require('./config.json');\nvar recon = require('recon-js');\nvar proto = require('swim-proto-js');\nvar WebSocket = global.WebSocket || require('websocket').w3cwebsocket;\n\nvar LINK_FAILED = -2;\nvar LINK_BROKEN = -1;\nvar LINK_WANTED = 0;\nvar LINK_ACTIVE = 1;\n\nfunction auth(node, query) {\n  Channel.auth(node, query);\n}\n\nfunction sync(node, lane, handle) {\n  Channel.get(node).sync(node, lane, handle);\n}\n\nfunction link(node, lane, handle) {\n  Channel.get(node).link(node, lane, handle);\n}\n\nfunction proxySync(proxy, node, lane, handle) {\n  Channel.get(proxy).sync(node, lane, handle);\n}\n\nfunction proxyLink(proxy, node, lane, handle) {\n  Channel.get(proxy).link(node, lane, handle);\n}\n\nfunction unlink(node, lane, handle) {\n  Channel.get(node).unlink(node, lane, handle);\n}\n\nfunction sendEvent(node, lane, body) {\n  Channel.get(node).sendEvent(node, lane, body);\n}\n\nfunction sendCommand(node, lane, body) {\n  Channel.get(node).sendCommand(node, lane, body);\n}\n\nfunction reset() {\n  for (var endpoint in Channel.bridge) {\n    var channel = Channel.bridge[endpoint];\n    channel.sendBuffer = [];\n    channel.unlinkAll();\n    channel.close();\n  }\n  Channel.bridge = {};\n}\n\n\nfunction Channel(node, query) {\n  Channel.bridge[node] = this;\n  this.node = node;\n  this.query = query;\n  this.linkCount = 0;\n  this.linkHandles = {};\n  this.sendBuffer = [];\n  this.reconnectTimeout = null;\n  this.reconnectTime = 250 + Math.round(Math.random() * 750);\n  this.closed = false;\n  this.open();\n}\nChannel.prototype.open = function () {\n  var requestUri = this.node;\n  if (this.query) requestUri = requestUri + '?' + this.query;\n  this.socket = new WebSocket(requestUri);\n  this.socket.onopen = this.onOpen.bind(this);\n  this.socket.onclose = this.onClose.bind(this);\n  this.socket.onmessage = this.onFrame.bind(this);\n  this.socket.onerror = this.onError.bind(this);\n};\nChannel.prototype.close = function () {\n  this.closed = true;\n  this.socket.close();\n};\nChannel.prototype.send = function (envelope) {\n  if (this.socket.readyState !== this.socket.OPEN) this.buffer(envelope);\n  else this.socket.send(proto.stringify(envelope));\n};\nChannel.prototype.buffer = function (envelope) {\n  if (envelope.isSyncRequest || envelope.isLinkRequest || envelope.isUnlinkRequest) return;\n  if (this.sendBuffer.length > config.SEND_BUFFER_SIZE) return; // TODO: Notify\n  this.sendBuffer.push(envelope);\n};\nChannel.prototype.onOpen = function () {\n  clearTimeout(this.reconnectTimeout);\n  this.reconnectTime = 250 + Math.round(Math.random() * 750);\n\n  var envelope;\n  for (var node in this.linkHandles) {\n    var nodeHandles = this.linkHandles[node];\n    for (var lane in nodeHandles) {\n      var laneHandles = nodeHandles[lane];\n      var synced = false;\n      for (var i = 0, n = laneHandles.length; !synced && i < n; i += 1) {\n        var handle = laneHandles[i];\n        var state = handle.__swim_link_state__;\n        synced = synced || state.synced;\n      }\n      if (synced) envelope = new proto.SyncRequest(this.unresolve(node), lane);\n      else envelope = new proto.LinkRequest(this.unresolve(node), lane);\n      this.send(envelope);\n    }\n  }\n\n  while ((envelope = this.sendBuffer.shift())) this.send(envelope);\n};\nChannel.prototype.onClose = function () {\n  if (!this.closed && this.linkCount === 0 && this.sendBuffer.length === 0) {\n    delete Channel.bridge[this.node];\n    return;\n  }\n\n  for (var node in this.linkHandles) {\n    var nodeHandles = this.linkHandles[node];\n    for (var lane in nodeHandles) {\n      var laneHandles = nodeHandles[lane];\n      for (var i = 0, n = laneHandles.length; i < n; i += 1) {\n        var handle = laneHandles[i];\n        var state = handle.__swim_link_state__;\n        if (state.status === LINK_ACTIVE) {\n          if (typeof handle.onBroken === 'function') {\n            handle.onBroken.call(handle, node, lane);\n          }\n          state.status = LINK_BROKEN;\n        }\n      }\n    }\n  }\n\n  if (!this.closed) {\n    this.reconnectTimeout = setTimeout(this.open.bind(this), this.reconnectTime);\n    this.reconnectTime = Math.min(2 * this.reconnectTime, config.MAX_RECONNECT_TIME);\n  }\n};\nChannel.prototype.onError = function () {\n  if (this.socket.readyState === this.socket.OPEN) {\n    this.socket.close();\n  }\n};\nChannel.prototype.onFrame = function (frame) {\n  var payload = frame.data;\n  if (typeof payload === 'string') {\n    var envelope = proto.parse(payload);\n    if (envelope) this.onReceive(envelope);\n  }\n};\nChannel.prototype.initHandle = function (handle, synced) {\n  if (typeof handle === 'function') handle = {\n    onEvent: handle,\n    onCommand: handle\n  };\n  var state = {\n    status: LINK_WANTED,\n    synced: synced\n  };\n  Object.defineProperty(handle, '__swim_link_state__', {value: state, configurable: true});\n  return handle;\n};\nChannel.prototype.registerHandle = function (node, lane, handle) {\n  var unlinked = false;\n  var nodeHandles = this.linkHandles[node];\n  if (nodeHandles === undefined) {\n    nodeHandles = {};\n    this.linkHandles[node] = nodeHandles;\n  }\n  var laneHandles = nodeHandles[lane];\n  if (laneHandles === undefined) {\n    unlinked = true;\n    laneHandles = [];\n    nodeHandles[lane] = laneHandles;\n  }\n  laneHandles.push(handle);\n  return unlinked;\n};\nChannel.prototype.unregisterHandle = function (node, lane, handle) {\n  var nodeHandles = this.linkHandles[node];\n  if (nodeHandles === undefined) return;\n  var laneHandles = nodeHandles[lane];\n  if (laneHandles === undefined) return;\n  var index = -1;\n  if (handle instanceof Function) for (var i = 0, n = laneHandles.length; i < n; i += 1) {\n    if (laneHandles[i].onEvent === handle) { index = i; break; }\n  }\n  else index = laneHandles.indexOf(handle);\n  if (index < 0) return false;\n  laneHandles.splice(index, 1);\n  var unlinked = laneHandles.length === 0;\n  if (unlinked) {\n    delete nodeHandles[lane];\n    if (Object.keys(nodeHandles).length === 0) delete this.linkHandles[node];\n  }\n  return unlinked;\n};\nChannel.prototype.sync = function (node, lane, handle) {\n  handle = this.initHandle(handle, true);\n  var unlinked = this.registerHandle(node, lane, handle);\n  var request = new proto.SyncRequest(this.unresolve(node), lane);\n  this.send(request);\n  if (unlinked) {\n    this.linkCount += 1;\n  }\n};\nChannel.prototype.link = function (node, lane, handle) {\n  handle = this.initHandle(handle, false);\n  var unlinked = this.registerHandle(node, lane, handle);\n  if (unlinked) {\n    var request = new proto.LinkRequest(this.unresolve(node), lane);\n    this.send(request);\n    this.linkCount += 1;\n  }\n  else if (this.socket.readyState === this.socket.OPEN) {\n    var state = handle.__swim_link_state__;\n    state.status = LINK_ACTIVE;\n    if (typeof handle.onLinked === 'function') {\n      handle.onLinked.call(handle, node, lane);\n    }\n  }\n};\nChannel.prototype.unlink = function (node, lane, handle) {\n  var unlinked = this.unregisterHandle(node, lane, handle);\n  if (unlinked) {\n    var request = new proto.UnlinkRequest(this.unresolve(node), lane);\n    this.send(request);\n    this.linkCount -= 1;\n  }\n};\nChannel.prototype.unlinkAll = function () {\n  for (var node in this.linkHandles) {\n    var nodeHandles = this.linkHandles[node];\n    for (var lane in nodeHandles) {\n      var laneHandles = nodeHandles[lane];\n      for (var i = 0, n = laneHandles.length; i < n; i += 1) {\n        var handle = laneHandles[i];\n        var state = handle.__swim_link_state__;\n        if (typeof handle.onFailed === 'function') {\n          handle.onFailed.call(handle, node, lane);\n        }\n        state.status = LINK_FAILED;\n      }\n    }\n  }\n  this.linkCount = 0;\n  this.linkHandles = {};\n};\nChannel.prototype.sendEvent = function (node, lane, body) {\n  var message = new proto.EventMessage(this.unresolve(node), lane, undefined, body);\n  this.send(message);\n};\nChannel.prototype.sendCommand = function (node, lane, body) {\n  var message = new proto.CommandMessage(this.unresolve(node), lane, undefined, body);\n  this.send(message);\n};\nChannel.prototype.onReceive = function (envelope) {\n  if (envelope.isEventMessage) this.onMessage(envelope);\n  else if (envelope.isCommandMessage) this.onMessage(envelope);\n  else if (envelope.isSyncedResponse) this.onSynced(envelope);\n  else if (envelope.isLinkedResponse) this.onLinked(envelope);\n  else if (envelope.isUnlinkedResponse) this.onUnlinked(envelope);\n};\nChannel.prototype.onMessage = function (envelope) {\n  var node = recon.uri.stringify(recon.uri.resolve(this.node, envelope.node));\n  var nodeHandles = this.linkHandles[node];\n  if (nodeHandles === undefined) return;\n\n  var lane = envelope.lane;\n  while (lane) {\n    var laneHandles = nodeHandles[lane];\n    if (laneHandles) for (var i = 0, n = laneHandles.length; i < n; i += 1) {\n      var handle = laneHandles[i];\n      if (envelope.isEventMessage) {\n        if (typeof handle.onEvent === 'function') {\n          handle.onEvent.call(handle, envelope);\n        }\n      }\n      else if (envelope.isCommandMessage) {\n        if (typeof handle.onCommand === 'function') {\n          handle.onCommand.call(handle, envelope);\n        }\n      }\n    }\n    lane = Channel.parentLane(lane);\n  }\n};\nChannel.prototype.onSynced = function (envelope) {\n  var node = recon.uri.stringify(recon.uri.resolve(this.node, envelope.node));\n  var lane = envelope.lane;\n  var nodeHandles = this.linkHandles[node];\n  if (nodeHandles === undefined) return;\n  var laneHandles = nodeHandles[lane];\n  if (laneHandles === undefined) return;\n  for (var i = 0, n = laneHandles.length; i < n; i += 1) {\n    var handle = laneHandles[i];\n    if (typeof handle.onLinked === 'function') {\n      handle.onSynced.call(handle, node, lane);\n    }\n  }\n};\nChannel.prototype.onLinked = function (envelope) {\n  var node = recon.uri.stringify(recon.uri.resolve(this.node, envelope.node));\n  var lane = envelope.lane;\n  var nodeHandles = this.linkHandles[node];\n  if (nodeHandles === undefined) return;\n  var laneHandles = nodeHandles[lane];\n  if (laneHandles === undefined) return;\n  for (var i = 0, n = laneHandles.length; i < n; i += 1) {\n    var handle = laneHandles[i];\n    var state = handle.__swim_link_state__;\n    if (state.status === LINK_BROKEN) {\n      if (typeof handle.onUnbroken === 'function') {\n        handle.onUnbroken.call(handle, node, lane);\n      }\n    }\n    else if (typeof handle.onLinked === 'function') {\n      handle.onLinked.call(handle, node, lane);\n    }\n    state.status = LINK_ACTIVE;\n  }\n};\nChannel.prototype.onUnlinked = function (envelope) {\n  var node = recon.uri.stringify(recon.uri.resolve(this.node, envelope.node));\n  var lane = envelope.lane;\n  var nodeHandles = this.linkHandles[node];\n  if (nodeHandles === undefined) return;\n  var laneHandles = nodeHandles[lane];\n  if (laneHandles === undefined) return;\n  for (var i = 0, n = laneHandles.length; i < n; i += 1) {\n    var handle = laneHandles[i];\n    var state = handle.__swim_link_state__;\n    if (state.status === LINK_ACTIVE) {\n      if (typeof handle.onUnlinked === 'function') {\n        handle.onUnlinked.call(handle, node, lane);\n      }\n      state.status = LINK_WANTED;\n    }\n    else {\n      if (typeof handle.onFailed === 'function') {\n        handle.onFailed.call(handle, node, lane);\n      }\n      state.status = LINK_FAILED;\n    }\n  }\n  delete nodeHandles[lane];\n  if (Object.keys(nodeHandles).length === 0) delete this.linkHandles[node];\n  this.linkCount -= 1;\n};\nChannel.prototype.unresolve = function (node) {\n  return recon.uri.stringify(recon.uri.unresolve(this.node, node));\n};\nChannel.bridge = {};\nChannel.get = function (node) {\n  var endpoint = Channel.endpoint(node);\n  var channel = Channel.bridge[endpoint];\n  if (channel === undefined) channel = new Channel(endpoint);\n  return channel;\n};\nChannel.auth = function (node, query) {\n  var endpoint = Channel.endpoint(node);\n  var channel = Channel.bridge[endpoint];\n  if (channel) {\n    channel.unlinkAll();\n    channel.close();\n    delete Channel.bridge[endpoint];\n  }\n  channel = new Channel(endpoint, query);\n  return channel;\n};\nChannel.endpoint = function (node) {\n  var components = recon.uri.parse(node);\n  var scheme = components.scheme;\n  if (scheme === 'swim') scheme = 'ws';\n  else if (scheme === 'swims') scheme = 'wss';\n  return recon.uri.stringify({\n    scheme: scheme,\n    authority: components.authority\n  });\n};\nChannel.parentLane = function (lane) {\n  var components = recon.uri.parse(lane);\n  var path = components.path;\n  if (components.query && components.fragment) return recon.uri.stringify({\n    path: path,\n    query: components.query\n  });\n  else if (components.query) return recon.uri.stringify({path: path});\n  else if (path.length > 0) {\n    return recon.uri.stringify({path: path.slice(0, path.length - 1)});\n  }\n};\n\n\nexports.auth = auth;\nexports.sync = sync;\nexports.link = link;\nexports.proxySync = proxySync;\nexports.proxyLink = proxyLink;\nexports.unlink = unlink;\nexports.sendEvent = sendEvent;\nexports.sendCommand = sendCommand;\nexports.reset = reset;\nexports.config = config;\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"./config.json\":1,\"recon-js\":\"recon-js\",\"swim-proto-js\":4,\"websocket\":2}]},{},[])(\"swim-client-js\")\n});\n\n","module.exports={\"version\":\"0.3.0\"}","'use strict';\n\nvar config = require('./config.json');\nvar recon = require('recon-js');\n\nfunction decode(record) {\n  switch (recon.tag(record)) {\n    case '@event': return EventMessage.decode(record);\n    case '@command': return CommandMessage.decode(record);\n    case '@sync': return SyncRequest.decode(record);\n    case '@synced': return SyncedResponse.decode(record);\n    case '@link': return LinkRequest.decode(record);\n    case '@linked': return LinkedResponse.decode(record);\n    case '@unlink': return UnlinkRequest.decode(record);\n    case '@unlinked': return UnlinkedResponse.decode(record);\n  }\n}\n\nfunction encode(envelope) {\n  return envelope.encode();\n}\n\nfunction parse(string) {\n  return decode(recon.parse(string));\n}\n\nfunction stringify(envelope) {\n  return recon.stringify(encode(envelope));\n}\n\n\nfunction Envelope() {}\nObject.defineProperty(Envelope.prototype, 'isRequest', {value: false});\nObject.defineProperty(Envelope.prototype, 'isResponse', {value: false});\nObject.defineProperty(Envelope.prototype, 'isMessage', {value: false});\nObject.defineProperty(Envelope.prototype, 'isEventMessage', {value: false});\nObject.defineProperty(Envelope.prototype, 'isCommandMessage', {value: false});\nObject.defineProperty(Envelope.prototype, 'isSyncRequest', {value: false});\nObject.defineProperty(Envelope.prototype, 'isSyncedResponse', {value: false});\nObject.defineProperty(Envelope.prototype, 'isLinkRequest', {value: false});\nObject.defineProperty(Envelope.prototype, 'isLinkedResponse', {value: false});\nObject.defineProperty(Envelope.prototype, 'isUnlinkRequest', {value: false});\nObject.defineProperty(Envelope.prototype, 'isUnlinkedResponse', {value: false});\n\n\nfunction RequestEnvelope() {\n  Envelope.call(this);\n}\nRequestEnvelope.prototype = Object.create(Envelope.prototype);\nRequestEnvelope.prototype.constructor = RequestEnvelope;\nObject.defineProperty(RequestEnvelope.prototype, 'isRequest', {value: true});\n\n\nfunction ResponseEnvelope() {\n  Envelope.call(this);\n}\nResponseEnvelope.prototype = Object.create(Envelope.prototype);\nResponseEnvelope.prototype.constructor = ResponseEnvelope;\nObject.defineProperty(RequestEnvelope.prototype, 'isResponse', {value: true});\n\n\nfunction MessageEnvelope() {\n  Envelope.call(this);\n}\nMessageEnvelope.prototype = Object.create(Envelope.prototype);\nMessageEnvelope.prototype.constructor = MessageEnvelope;\nObject.defineProperty(RequestEnvelope.prototype, 'isMessage', {value: true});\n\n\nfunction EventMessage(node, lane, via, body) {\n  MessageEnvelope.call(this);\n  this.node = node;\n  this.lane = lane;\n  this.via = via;\n  this.body = body;\n}\nEventMessage.prototype = Object.create(MessageEnvelope.prototype);\nEventMessage.prototype.constructor = EventMessage;\nObject.defineProperty(EventMessage.prototype, 'isEventMessage', {value: true});\nEventMessage.prototype.encode = function () {\n  var headers = [{node: this.node}, {lane: this.lane}];\n  if (this.via) headers.push({via: this.via});\n  return recon.concat({'@event': headers}, this.body);\n};\nEventMessage.decode = function (record) {\n  var node, lane, via;\n  var body = recon.tail(record);\n  var headers = recon.head(record);\n  var n = headers && headers.length || 0;\n  for (var i = 0; i < n; i += 1) {\n    var header = headers[i];\n    if (header.node !== undefined) node = header.node;\n    else if (header.lane !== undefined) lane = header.lane;\n    else if (header.via !== undefined) via = header.via;\n    else if (i === 0) node = header;\n    else if (i === 1) lane = header;\n    else if (i === 2) via = header;\n  }\n  if (node !== undefined && lane !== undefined) {\n    return new EventMessage(node, lane, via, body);\n  }\n};\n\n\nfunction CommandMessage(node, lane, via, body) {\n  MessageEnvelope.call(this);\n  this.node = node;\n  this.lane = lane;\n  this.via = via;\n  this.body = body;\n}\nCommandMessage.prototype = Object.create(MessageEnvelope.prototype);\nCommandMessage.prototype.constructor = CommandMessage;\nObject.defineProperty(CommandMessage.prototype, 'isCommandMessage', {value: true});\nCommandMessage.prototype.encode = function () {\n  var headers = [{node: this.node}, {lane: this.lane}];\n  if (this.via) headers.push({via: this.via});\n  return recon.concat({'@command': headers}, this.body);\n};\nCommandMessage.decode = function (record) {\n  var node, lane, via;\n  var body = recon.tail(record);\n  var headers = recon.head(record);\n  var n = headers && headers.length || 0;\n  for (var i = 0; i < n; i += 1) {\n    var header = headers[i];\n    if (header.node !== undefined) node = header.node;\n    else if (header.lane !== undefined) lane = header.lane;\n    else if (header.via !== undefined) via = header.via;\n    else if (i === 0) node = header;\n    else if (i === 1) lane = header;\n    else if (i === 2) via = header;\n  }\n  if (node !== undefined && lane !== undefined) {\n    return new CommandMessage(node, lane, via, body);\n  }\n};\n\n\nfunction SyncRequest(node, lane, prio) {\n  RequestEnvelope.call(this);\n  this.node = node;\n  this.lane = lane;\n  this.prio = prio || 0.0;\n}\nSyncRequest.prototype = Object.create(RequestEnvelope.prototype);\nSyncRequest.prototype.constructor = SyncRequest;\nObject.defineProperty(SyncRequest.prototype, 'isSyncRequest', {value: true});\nSyncRequest.prototype.encode = function () {\n  var headers = [{node: this.node}, {lane: this.lane}];\n  if (this.prio) headers.push({prio: this.prio});\n  return recon({'@sync': headers});\n};\nSyncRequest.decode = function (record) {\n  var node, lane, prio;\n  var headers = recon.head(record);\n  var n = headers && headers.length || 0;\n  for (var i = 0; i < n; i += 1) {\n    var header = headers[i];\n    if (header.node !== undefined) node = header.node;\n    else if (header.lane !== undefined) lane = header.lane;\n    else if (header.prio !== undefined) prio = header.prio;\n    else if (i === 0) node = header;\n    else if (i === 1) lane = header;\n  }\n  if (node !== undefined && lane !== undefined) {\n    return new SyncRequest(node, lane, prio);\n  }\n};\n\n\nfunction SyncedResponse(node, lane) {\n  ResponseEnvelope.call(this);\n  this.node = node;\n  this.lane = lane;\n}\nSyncedResponse.prototype = Object.create(ResponseEnvelope.prototype);\nSyncedResponse.prototype.constructor = SyncedResponse;\nObject.defineProperty(SyncedResponse.prototype, 'isSyncedResponse', {value: true});\nSyncedResponse.prototype.encode = function () {\n  var headers = [{node: this.node}, {lane: this.lane}];\n  return recon({'@synced': headers});\n};\nSyncedResponse.decode = function (record) {\n  var node, lane;\n  var headers = recon.head(record);\n  var n = headers && headers.length || 0;\n  for (var i = 0; i < n; i += 1) {\n    var header = headers[i];\n    if (header.node !== undefined) node = header.node;\n    else if (header.lane !== undefined) lane = header.lane;\n    else if (i === 0) node = header;\n    else if (i === 1) lane = header;\n  }\n  if (node !== undefined && lane !== undefined) {\n    return new SyncedResponse(node, lane);\n  }\n};\n\n\nfunction LinkRequest(node, lane, prio) {\n  RequestEnvelope.call(this);\n  this.node = node;\n  this.lane = lane;\n  this.prio = prio || 0.0;\n}\nLinkRequest.prototype = Object.create(RequestEnvelope.prototype);\nLinkRequest.prototype.constructor = LinkRequest;\nObject.defineProperty(LinkRequest.prototype, 'isLinkRequest', {value: true});\nLinkRequest.prototype.encode = function () {\n  var headers = [{node: this.node}, {lane: this.lane}];\n  if (this.prio) headers.push({prio: this.prio});\n  return recon({'@link': headers});\n};\nLinkRequest.decode = function (record) {\n  var node, lane, prio;\n  var headers = recon.head(record);\n  var n = headers && headers.length || 0;\n  for (var i = 0; i < n; i += 1) {\n    var header = headers[i];\n    if (header.node !== undefined) node = header.node;\n    else if (header.lane !== undefined) lane = header.lane;\n    else if (header.prio !== undefined) prio = header.prio;\n    else if (i === 0) node = header;\n    else if (i === 1) lane = header;\n  }\n  if (node !== undefined && lane !== undefined) {\n    return new LinkRequest(node, lane, prio);\n  }\n};\n\n\nfunction LinkedResponse(node, lane, prio) {\n  ResponseEnvelope.call(this);\n  this.node = node;\n  this.lane = lane;\n  this.prio = prio || 0.0;\n}\nLinkedResponse.prototype = Object.create(ResponseEnvelope.prototype);\nLinkedResponse.prototype.constructor = LinkedResponse;\nObject.defineProperty(LinkedResponse.prototype, 'isLinkedResponse', {value: true});\nLinkedResponse.prototype.encode = function () {\n  var headers = [{node: this.node}, {lane: this.lane}];\n  if (this.prio) headers.push({prio: this.prio});\n  return recon({'@linked': headers});\n};\nLinkedResponse.decode = function (record) {\n  var node, lane, prio;\n  var headers = recon.head(record);\n  var n = headers && headers.length || 0;\n  for (var i = 0; i < n; i += 1) {\n    var header = headers[i];\n    if (header.node !== undefined) node = header.node;\n    else if (header.lane !== undefined) lane = header.lane;\n    else if (header.prio !== undefined) prio = header.prio;\n    else if (i === 0) node = header;\n    else if (i === 1) lane = header;\n  }\n  if (node !== undefined && lane !== undefined) {\n    return new LinkedResponse(node, lane, prio);\n  }\n};\n\n\nfunction UnlinkRequest(node, lane) {\n  RequestEnvelope.call(this);\n  this.node = node;\n  this.lane = lane;\n}\nUnlinkRequest.prototype = Object.create(RequestEnvelope.prototype);\nUnlinkRequest.prototype.constructor = UnlinkRequest;\nObject.defineProperty(UnlinkRequest.prototype, 'isUnlinkRequest', {value: true});\nUnlinkRequest.prototype.encode = function () {\n  var headers = [{node: this.node}, {lane: this.lane}];\n  return recon({'@unlink': headers});\n};\nUnlinkRequest.decode = function (record) {\n  var node, lane;\n  var headers = recon.head(record);\n  var n = headers && headers.length || 0;\n  for (var i = 0; i < n; i += 1) {\n    var header = headers[i];\n    if (header.node !== undefined) node = header.node;\n    else if (header.lane !== undefined) lane = header.lane;\n    else if (i === 0) node = header;\n    else if (i === 1) lane = header;\n  }\n  if (node !== undefined && lane !== undefined) {\n    return new UnlinkRequest(node, lane);\n  }\n};\n\n\nfunction UnlinkedResponse(node, lane) {\n  ResponseEnvelope.call(this);\n  this.node = node;\n  this.lane = lane;\n}\nUnlinkedResponse.prototype = Object.create(ResponseEnvelope.prototype);\nUnlinkedResponse.prototype.constructor = UnlinkedResponse;\nObject.defineProperty(UnlinkedResponse.prototype, 'isUnlinkedResponse', {value: true});\nUnlinkedResponse.prototype.encode = function () {\n  var headers = [{node: this.node}, {lane: this.lane}];\n  return recon({'@unlinked': headers});\n};\nUnlinkedResponse.decode = function (record) {\n  var node, lane;\n  var headers = recon.head(record);\n  var n = headers && headers.length || 0;\n  for (var i = 0; i < n; i += 1) {\n    var header = headers[i];\n    if (header.node !== undefined) node = header.node;\n    else if (header.lane !== undefined) lane = header.lane;\n    else if (i === 0) node = header;\n    else if (i === 1) lane = header;\n  }\n  if (node !== undefined && lane !== undefined) {\n    return new UnlinkedResponse(node, lane);\n  }\n};\n\n\nexports.decode = decode;\nexports.encode = encode;\nexports.parse = parse;\nexports.stringify = stringify;\nexports.Envelope = Envelope;\nexports.RequestEnvelope = RequestEnvelope;\nexports.ResponseEnvelope = ResponseEnvelope;\nexports.MessageEnvelope = MessageEnvelope;\nexports.EventMessage = EventMessage;\nexports.CommandMessage = CommandMessage;\nexports.SyncRequest = SyncRequest;\nexports.SyncedResponse = SyncedResponse;\nexports.LinkRequest = LinkRequest;\nexports.LinkedResponse = LinkedResponse;\nexports.UnlinkRequest = UnlinkRequest;\nexports.UnlinkedResponse = UnlinkedResponse;\nexports.config = config;\n","'use strict';\n\nvar config = require('./config.json');\nvar recon = require('recon-js');\nvar proto = require('swim-proto-js');\nvar WebSocket = global.WebSocket || require('websocket').w3cwebsocket;\n\nvar LINK_FAILED = -2;\nvar LINK_BROKEN = -1;\nvar LINK_WANTED = 0;\nvar LINK_ACTIVE = 1;\n\nfunction auth(node, query) {\n  Channel.auth(node, query);\n}\n\nfunction sync(node, lane, handle) {\n  Channel.get(node).sync(node, lane, handle);\n}\n\nfunction link(node, lane, handle) {\n  Channel.get(node).link(node, lane, handle);\n}\n\nfunction proxySync(proxy, node, lane, handle) {\n  Channel.get(proxy).sync(node, lane, handle);\n}\n\nfunction proxyLink(proxy, node, lane, handle) {\n  Channel.get(proxy).link(node, lane, handle);\n}\n\nfunction unlink(node, lane, handle) {\n  Channel.get(node).unlink(node, lane, handle);\n}\n\nfunction sendEvent(node, lane, body) {\n  Channel.get(node).sendEvent(node, lane, body);\n}\n\nfunction sendCommand(node, lane, body) {\n  Channel.get(node).sendCommand(node, lane, body);\n}\n\nfunction reset() {\n  for (var endpoint in Channel.bridge) {\n    var channel = Channel.bridge[endpoint];\n    channel.sendBuffer = [];\n    channel.unlinkAll();\n    channel.close();\n  }\n  Channel.bridge = {};\n}\n\n\nfunction Channel(node, query) {\n  Channel.bridge[node] = this;\n  this.node = node;\n  this.query = query;\n  this.linkCount = 0;\n  this.linkHandles = {};\n  this.sendBuffer = [];\n  this.reconnectTimeout = null;\n  this.reconnectTime = 250 + Math.round(Math.random() * 750);\n  this.closed = false;\n  this.open();\n}\nChannel.prototype.open = function () {\n  var requestUri = this.node;\n  if (this.query) requestUri = requestUri + '?' + this.query;\n  this.socket = new WebSocket(requestUri);\n  this.socket.onopen = this.onOpen.bind(this);\n  this.socket.onclose = this.onClose.bind(this);\n  this.socket.onmessage = this.onFrame.bind(this);\n  this.socket.onerror = this.onError.bind(this);\n};\nChannel.prototype.close = function () {\n  this.closed = true;\n  this.socket.close();\n};\nChannel.prototype.send = function (envelope) {\n  if (this.socket.readyState !== this.socket.OPEN) this.buffer(envelope);\n  else this.socket.send(proto.stringify(envelope));\n};\nChannel.prototype.buffer = function (envelope) {\n  if (envelope.isSyncRequest || envelope.isLinkRequest || envelope.isUnlinkRequest) return;\n  if (this.sendBuffer.length > config.SEND_BUFFER_SIZE) return; // TODO: Notify\n  this.sendBuffer.push(envelope);\n};\nChannel.prototype.onOpen = function () {\n  clearTimeout(this.reconnectTimeout);\n  this.reconnectTime = 250 + Math.round(Math.random() * 750);\n\n  var envelope;\n  for (var node in this.linkHandles) {\n    var nodeHandles = this.linkHandles[node];\n    for (var lane in nodeHandles) {\n      var laneHandles = nodeHandles[lane];\n      var synced = false;\n      for (var i = 0, n = laneHandles.length; !synced && i < n; i += 1) {\n        var handle = laneHandles[i];\n        var state = handle.__swim_link_state__;\n        synced = synced || state.synced;\n      }\n      if (synced) envelope = new proto.SyncRequest(this.unresolve(node), lane);\n      else envelope = new proto.LinkRequest(this.unresolve(node), lane);\n      this.send(envelope);\n    }\n  }\n\n  while ((envelope = this.sendBuffer.shift())) this.send(envelope);\n};\nChannel.prototype.onClose = function () {\n  if (!this.closed && this.linkCount === 0 && this.sendBuffer.length === 0) {\n    delete Channel.bridge[this.node];\n    return;\n  }\n\n  for (var node in this.linkHandles) {\n    var nodeHandles = this.linkHandles[node];\n    for (var lane in nodeHandles) {\n      var laneHandles = nodeHandles[lane];\n      for (var i = 0, n = laneHandles.length; i < n; i += 1) {\n        var handle = laneHandles[i];\n        var state = handle.__swim_link_state__;\n        if (state.status === LINK_ACTIVE) {\n          if (typeof handle.onBroken === 'function') {\n            handle.onBroken.call(handle, node, lane);\n          }\n          state.status = LINK_BROKEN;\n        }\n      }\n    }\n  }\n\n  if (!this.closed) {\n    this.reconnectTimeout = setTimeout(this.open.bind(this), this.reconnectTime);\n    this.reconnectTime = Math.min(2 * this.reconnectTime, config.MAX_RECONNECT_TIME);\n  }\n};\nChannel.prototype.onError = function () {\n  if (this.socket.readyState === this.socket.OPEN) {\n    this.socket.close();\n  }\n};\nChannel.prototype.onFrame = function (frame) {\n  var payload = frame.data;\n  if (typeof payload === 'string') {\n    var envelope = proto.parse(payload);\n    if (envelope) this.onReceive(envelope);\n  }\n};\nChannel.prototype.initHandle = function (handle, synced) {\n  if (typeof handle === 'function') handle = {\n    onEvent: handle,\n    onCommand: handle\n  };\n  var state = {\n    status: LINK_WANTED,\n    synced: synced\n  };\n  Object.defineProperty(handle, '__swim_link_state__', {value: state, configurable: true});\n  return handle;\n};\nChannel.prototype.registerHandle = function (node, lane, handle) {\n  var unlinked = false;\n  var nodeHandles = this.linkHandles[node];\n  if (nodeHandles === undefined) {\n    nodeHandles = {};\n    this.linkHandles[node] = nodeHandles;\n  }\n  var laneHandles = nodeHandles[lane];\n  if (laneHandles === undefined) {\n    unlinked = true;\n    laneHandles = [];\n    nodeHandles[lane] = laneHandles;\n  }\n  laneHandles.push(handle);\n  return unlinked;\n};\nChannel.prototype.unregisterHandle = function (node, lane, handle) {\n  var nodeHandles = this.linkHandles[node];\n  if (nodeHandles === undefined) return;\n  var laneHandles = nodeHandles[lane];\n  if (laneHandles === undefined) return;\n  var index = -1;\n  if (handle instanceof Function) for (var i = 0, n = laneHandles.length; i < n; i += 1) {\n    if (laneHandles[i].onEvent === handle) { index = i; break; }\n  }\n  else index = laneHandles.indexOf(handle);\n  if (index < 0) return false;\n  laneHandles.splice(index, 1);\n  var unlinked = laneHandles.length === 0;\n  if (unlinked) {\n    delete nodeHandles[lane];\n    if (Object.keys(nodeHandles).length === 0) delete this.linkHandles[node];\n  }\n  return unlinked;\n};\nChannel.prototype.sync = function (node, lane, handle) {\n  handle = this.initHandle(handle, true);\n  var unlinked = this.registerHandle(node, lane, handle);\n  var request = new proto.SyncRequest(this.unresolve(node), lane);\n  this.send(request);\n  if (unlinked) {\n    this.linkCount += 1;\n  }\n};\nChannel.prototype.link = function (node, lane, handle) {\n  handle = this.initHandle(handle, false);\n  var unlinked = this.registerHandle(node, lane, handle);\n  if (unlinked) {\n    var request = new proto.LinkRequest(this.unresolve(node), lane);\n    this.send(request);\n    this.linkCount += 1;\n  }\n  else if (this.socket.readyState === this.socket.OPEN) {\n    var state = handle.__swim_link_state__;\n    state.status = LINK_ACTIVE;\n    if (typeof handle.onLinked === 'function') {\n      handle.onLinked.call(handle, node, lane);\n    }\n  }\n};\nChannel.prototype.unlink = function (node, lane, handle) {\n  var unlinked = this.unregisterHandle(node, lane, handle);\n  if (unlinked) {\n    var request = new proto.UnlinkRequest(this.unresolve(node), lane);\n    this.send(request);\n    this.linkCount -= 1;\n  }\n};\nChannel.prototype.unlinkAll = function () {\n  for (var node in this.linkHandles) {\n    var nodeHandles = this.linkHandles[node];\n    for (var lane in nodeHandles) {\n      var laneHandles = nodeHandles[lane];\n      for (var i = 0, n = laneHandles.length; i < n; i += 1) {\n        var handle = laneHandles[i];\n        var state = handle.__swim_link_state__;\n        if (typeof handle.onFailed === 'function') {\n          handle.onFailed.call(handle, node, lane);\n        }\n        state.status = LINK_FAILED;\n      }\n    }\n  }\n  this.linkCount = 0;\n  this.linkHandles = {};\n};\nChannel.prototype.sendEvent = function (node, lane, body) {\n  var message = new proto.EventMessage(this.unresolve(node), lane, undefined, body);\n  this.send(message);\n};\nChannel.prototype.sendCommand = function (node, lane, body) {\n  var message = new proto.CommandMessage(this.unresolve(node), lane, undefined, body);\n  this.send(message);\n};\nChannel.prototype.onReceive = function (envelope) {\n  if (envelope.isEventMessage) this.onMessage(envelope);\n  else if (envelope.isCommandMessage) this.onMessage(envelope);\n  else if (envelope.isSyncedResponse) this.onSynced(envelope);\n  else if (envelope.isLinkedResponse) this.onLinked(envelope);\n  else if (envelope.isUnlinkedResponse) this.onUnlinked(envelope);\n};\nChannel.prototype.onMessage = function (envelope) {\n  var node = recon.uri.stringify(recon.uri.resolve(this.node, envelope.node));\n  var nodeHandles = this.linkHandles[node];\n  if (nodeHandles === undefined) return;\n\n  var lane = envelope.lane;\n  while (lane) {\n    var laneHandles = nodeHandles[lane];\n    if (laneHandles) for (var i = 0, n = laneHandles.length; i < n; i += 1) {\n      var handle = laneHandles[i];\n      if (envelope.isEventMessage) {\n        if (typeof handle.onEvent === 'function') {\n          handle.onEvent.call(handle, envelope);\n        }\n      }\n      else if (envelope.isCommandMessage) {\n        if (typeof handle.onCommand === 'function') {\n          handle.onCommand.call(handle, envelope);\n        }\n      }\n    }\n    lane = Channel.parentLane(lane);\n  }\n};\nChannel.prototype.onSynced = function (envelope) {\n  var node = recon.uri.stringify(recon.uri.resolve(this.node, envelope.node));\n  var lane = envelope.lane;\n  var nodeHandles = this.linkHandles[node];\n  if (nodeHandles === undefined) return;\n  var laneHandles = nodeHandles[lane];\n  if (laneHandles === undefined) return;\n  for (var i = 0, n = laneHandles.length; i < n; i += 1) {\n    var handle = laneHandles[i];\n    if (typeof handle.onLinked === 'function') {\n      handle.onSynced.call(handle, node, lane);\n    }\n  }\n};\nChannel.prototype.onLinked = function (envelope) {\n  var node = recon.uri.stringify(recon.uri.resolve(this.node, envelope.node));\n  var lane = envelope.lane;\n  var nodeHandles = this.linkHandles[node];\n  if (nodeHandles === undefined) return;\n  var laneHandles = nodeHandles[lane];\n  if (laneHandles === undefined) return;\n  for (var i = 0, n = laneHandles.length; i < n; i += 1) {\n    var handle = laneHandles[i];\n    var state = handle.__swim_link_state__;\n    if (state.status === LINK_BROKEN) {\n      if (typeof handle.onUnbroken === 'function') {\n        handle.onUnbroken.call(handle, node, lane);\n      }\n    }\n    else if (typeof handle.onLinked === 'function') {\n      handle.onLinked.call(handle, node, lane);\n    }\n    state.status = LINK_ACTIVE;\n  }\n};\nChannel.prototype.onUnlinked = function (envelope) {\n  var node = recon.uri.stringify(recon.uri.resolve(this.node, envelope.node));\n  var lane = envelope.lane;\n  var nodeHandles = this.linkHandles[node];\n  if (nodeHandles === undefined) return;\n  var laneHandles = nodeHandles[lane];\n  if (laneHandles === undefined) return;\n  for (var i = 0, n = laneHandles.length; i < n; i += 1) {\n    var handle = laneHandles[i];\n    var state = handle.__swim_link_state__;\n    if (state.status === LINK_ACTIVE) {\n      if (typeof handle.onUnlinked === 'function') {\n        handle.onUnlinked.call(handle, node, lane);\n      }\n      state.status = LINK_WANTED;\n    }\n    else {\n      if (typeof handle.onFailed === 'function') {\n        handle.onFailed.call(handle, node, lane);\n      }\n      state.status = LINK_FAILED;\n    }\n  }\n  delete nodeHandles[lane];\n  if (Object.keys(nodeHandles).length === 0) delete this.linkHandles[node];\n  this.linkCount -= 1;\n};\nChannel.prototype.unresolve = function (node) {\n  return recon.uri.stringify(recon.uri.unresolve(this.node, node));\n};\nChannel.bridge = {};\nChannel.get = function (node) {\n  var endpoint = Channel.endpoint(node);\n  var channel = Channel.bridge[endpoint];\n  if (channel === undefined) channel = new Channel(endpoint);\n  return channel;\n};\nChannel.auth = function (node, query) {\n  var endpoint = Channel.endpoint(node);\n  var channel = Channel.bridge[endpoint];\n  if (channel) {\n    channel.unlinkAll();\n    channel.close();\n    delete Channel.bridge[endpoint];\n  }\n  channel = new Channel(endpoint, query);\n  return channel;\n};\nChannel.endpoint = function (node) {\n  var components = recon.uri.parse(node);\n  var scheme = components.scheme;\n  if (scheme === 'swim') scheme = 'ws';\n  else if (scheme === 'swims') scheme = 'wss';\n  return recon.uri.stringify({\n    scheme: scheme,\n    authority: components.authority\n  });\n};\nChannel.parentLane = function (lane) {\n  var components = recon.uri.parse(lane);\n  var path = components.path;\n  if (components.query && components.fragment) return recon.uri.stringify({\n    path: path,\n    query: components.query\n  });\n  else if (components.query) return recon.uri.stringify({path: path});\n  else if (path.length > 0) {\n    return recon.uri.stringify({path: path.slice(0, path.length - 1)});\n  }\n};\n\n\nexports.auth = auth;\nexports.sync = sync;\nexports.link = link;\nexports.proxySync = proxySync;\nexports.proxyLink = proxyLink;\nexports.unlink = unlink;\nexports.sendEvent = sendEvent;\nexports.sendCommand = sendCommand;\nexports.reset = reset;\nexports.config = config;\n"],"sourceRoot":"/source/"}