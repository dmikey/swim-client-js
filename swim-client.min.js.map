{"version":3,"sources":["node_modules/browser-pack/_prelude.js","config.json","swim-client.min.js","node_modules/swim-proto-js/config.json","node_modules/swim-proto-js/swim-proto.js","swim-client.js"],"names":["f","exports","module","define","amd","g","window","global","self","this","swim","client","e","t","n","r","s","o","u","a","require","i","Error","code","l","call","length",1,"version","SEND_BUFFER_SIZE","MAX_RECONNECT_TIME",2,3,4,"decode","record","recon","tag","EventMessage","CommandMessage","SyncRequest","SyncedResponse","LinkRequest","LinkedResponse","UnlinkRequest","UnlinkedResponse","encode","envelope","parse","string","stringify","Envelope","RequestEnvelope","ResponseEnvelope","MessageEnvelope","node","lane","via","body","prio","config","Object","defineProperty","prototype","value","create","constructor","headers","push","concat","@event","tail","head","header","undefined","@command","@sync","@synced","@link","@linked","@unlink","@unlinked","./config.json","recon-js","swim-client-js","auth","query","Channel","sync","handle","get","link","unlink","sendEvent","sendCommand","reset","endpoint","bridge","channel","sendBuffer","unlinkAll","close","linkCount","linkHandles","reconnectTimeout","reconnectTime","Math","round","random","closed","open","proto","WebSocket","w3cwebsocket","LINK_FAILED","LINK_BROKEN","LINK_WANTED","LINK_ACTIVE","requestUri","socket","onopen","onOpen","bind","onclose","onClose","onmessage","onFrame","onerror","onError","send","readyState","OPEN","buffer","isSyncRequest","isLinkRequest","isUnlinkRequest","clearTimeout","nodeHandles","laneHandles","synced","state","__swim_link_state__","unresolve","shift","status","onBroken","setTimeout","min","frame","payload","data","onReceive","initHandle","onEvent","onCommand","configurable","registerHandle","unlinked","unregisterHandle","index","Function","indexOf","splice","keys","request","onLinked","onFailed","message","isEventMessage","onMessage","isCommandMessage","isSyncedResponse","onSynced","isLinkedResponse","isUnlinkedResponse","onUnlinked","uri","resolve","parentLane","onUnbroken","components","scheme","authority","path","fragment","slice","swim-proto-js","websocket"],"mappings":"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","file":"swim-client.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","module.exports={\"version\":\"0.3.0\",\"SEND_BUFFER_SIZE\":1024,\"MAX_RECONNECT_TIME\":15000}","(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}(g.swim || (g.swim = {})).client = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\nmodule.exports={\"version\":\"0.3.0\",\"SEND_BUFFER_SIZE\":1024,\"MAX_RECONNECT_TIME\":15000}\n},{}],2:[function(require,module,exports){\n\n},{}],3:[function(require,module,exports){\nmodule.exports={\"version\":\"0.3.0\"}\n},{}],4:[function(require,module,exports){\n'use strict';\n\nvar config = require('./config.json');\nvar recon = require('recon-js');\n\nfunction decode(record) {\n  switch (recon.tag(record)) {\n    case '@event': return EventMessage.decode(record);\n    case '@command': return CommandMessage.decode(record);\n    case '@sync': return SyncRequest.decode(record);\n    case '@synced': return SyncedResponse.decode(record);\n    case '@link': return LinkRequest.decode(record);\n    case '@linked': return LinkedResponse.decode(record);\n    case '@unlink': return UnlinkRequest.decode(record);\n    case '@unlinked': return UnlinkedResponse.decode(record);\n  }\n}\n\nfunction encode(envelope) {\n  return envelope.encode();\n}\n\nfunction parse(string) {\n  return decode(recon.parse(string));\n}\n\nfunction stringify(envelope) {\n  return recon.stringify(encode(envelope));\n}\n\n\nfunction Envelope() {}\nObject.defineProperty(Envelope.prototype, 'isRequest', {value: false});\nObject.defineProperty(Envelope.prototype, 'isResponse', {value: false});\nObject.defineProperty(Envelope.prototype, 'isMessage', {value: false});\nObject.defineProperty(Envelope.prototype, 'isEventMessage', {value: false});\nObject.defineProperty(Envelope.prototype, 'isCommandMessage', {value: false});\nObject.defineProperty(Envelope.prototype, 'isSyncRequest', {value: false});\nObject.defineProperty(Envelope.prototype, 'isSyncedResponse', {value: false});\nObject.defineProperty(Envelope.prototype, 'isLinkRequest', {value: false});\nObject.defineProperty(Envelope.prototype, 'isLinkedResponse', {value: false});\nObject.defineProperty(Envelope.prototype, 'isUnlinkRequest', {value: false});\nObject.defineProperty(Envelope.prototype, 'isUnlinkedResponse', {value: false});\n\n\nfunction RequestEnvelope() {\n  Envelope.call(this);\n}\nRequestEnvelope.prototype = Object.create(Envelope.prototype);\nRequestEnvelope.prototype.constructor = RequestEnvelope;\nObject.defineProperty(RequestEnvelope.prototype, 'isRequest', {value: true});\n\n\nfunction ResponseEnvelope() {\n  Envelope.call(this);\n}\nResponseEnvelope.prototype = Object.create(Envelope.prototype);\nResponseEnvelope.prototype.constructor = ResponseEnvelope;\nObject.defineProperty(RequestEnvelope.prototype, 'isResponse', {value: true});\n\n\nfunction MessageEnvelope() {\n  Envelope.call(this);\n}\nMessageEnvelope.prototype = Object.create(Envelope.prototype);\nMessageEnvelope.prototype.constructor = MessageEnvelope;\nObject.defineProperty(RequestEnvelope.prototype, 'isMessage', {value: true});\n\n\nfunction EventMessage(node, lane, via, body) {\n  MessageEnvelope.call(this);\n  this.node = node;\n  this.lane = lane;\n  this.via = via;\n  this.body = body;\n}\nEventMessage.prototype = Object.create(MessageEnvelope.prototype);\nEventMessage.prototype.constructor = EventMessage;\nObject.defineProperty(EventMessage.prototype, 'isEventMessage', {value: true});\nEventMessage.prototype.encode = function () {\n  var headers = [{node: this.node}, {lane: this.lane}];\n  if (this.via) headers.push({via: this.via});\n  return recon.concat({'@event': headers}, this.body);\n};\nEventMessage.decode = function (record) {\n  var node, lane, via;\n  var body = recon.tail(record);\n  var headers = recon.head(record);\n  var n = headers && headers.length || 0;\n  for (var i = 0; i < n; i += 1) {\n    var header = headers[i];\n    if (header.node !== undefined) node = header.node;\n    else if (header.lane !== undefined) lane = header.lane;\n    else if (header.via !== undefined) via = header.via;\n    else if (i === 0) node = header;\n    else if (i === 1) lane = header;\n    else if (i === 2) via = header;\n  }\n  if (node !== undefined && lane !== undefined) {\n    return new EventMessage(node, lane, via, body);\n  }\n};\n\n\nfunction CommandMessage(node, lane, via, body) {\n  MessageEnvelope.call(this);\n  this.node = node;\n  this.lane = lane;\n  this.via = via;\n  this.body = body;\n}\nCommandMessage.prototype = Object.create(MessageEnvelope.prototype);\nCommandMessage.prototype.constructor = CommandMessage;\nObject.defineProperty(CommandMessage.prototype, 'isCommandMessage', {value: true});\nCommandMessage.prototype.encode = function () {\n  var headers = [{node: this.node}, {lane: this.lane}];\n  if (this.via) headers.push({via: this.via});\n  return recon.concat({'@command': headers}, this.body);\n};\nCommandMessage.decode = function (record) {\n  var node, lane, via;\n  var body = recon.tail(record);\n  var headers = recon.head(record);\n  var n = headers && headers.length || 0;\n  for (var i = 0; i < n; i += 1) {\n    var header = headers[i];\n    if (header.node !== undefined) node = header.node;\n    else if (header.lane !== undefined) lane = header.lane;\n    else if (header.via !== undefined) via = header.via;\n    else if (i === 0) node = header;\n    else if (i === 1) lane = header;\n    else if (i === 2) via = header;\n  }\n  if (node !== undefined && lane !== undefined) {\n    return new CommandMessage(node, lane, via, body);\n  }\n};\n\n\nfunction SyncRequest(node, lane, prio) {\n  RequestEnvelope.call(this);\n  this.node = node;\n  this.lane = lane;\n  this.prio = prio || 0.0;\n}\nSyncRequest.prototype = Object.create(RequestEnvelope.prototype);\nSyncRequest.prototype.constructor = SyncRequest;\nObject.defineProperty(SyncRequest.prototype, 'isSyncRequest', {value: true});\nSyncRequest.prototype.encode = function () {\n  var headers = [{node: this.node}, {lane: this.lane}];\n  if (this.prio) headers.push({prio: this.prio});\n  return recon({'@sync': headers});\n};\nSyncRequest.decode = function (record) {\n  var node, lane, prio;\n  var headers = recon.head(record);\n  var n = headers && headers.length || 0;\n  for (var i = 0; i < n; i += 1) {\n    var header = headers[i];\n    if (header.node !== undefined) node = header.node;\n    else if (header.lane !== undefined) lane = header.lane;\n    else if (header.prio !== undefined) prio = header.prio;\n    else if (i === 0) node = header;\n    else if (i === 1) lane = header;\n  }\n  if (node !== undefined && lane !== undefined) {\n    return new SyncRequest(node, lane, prio);\n  }\n};\n\n\nfunction SyncedResponse(node, lane) {\n  ResponseEnvelope.call(this);\n  this.node = node;\n  this.lane = lane;\n}\nSyncedResponse.prototype = Object.create(ResponseEnvelope.prototype);\nSyncedResponse.prototype.constructor = SyncedResponse;\nObject.defineProperty(SyncedResponse.prototype, 'isSyncedResponse', {value: true});\nSyncedResponse.prototype.encode = function () {\n  var headers = [{node: this.node}, {lane: this.lane}];\n  return recon({'@synced': headers});\n};\nSyncedResponse.decode = function (record) {\n  var node, lane;\n  var headers = recon.head(record);\n  var n = headers && headers.length || 0;\n  for (var i = 0; i < n; i += 1) {\n    var header = headers[i];\n    if (header.node !== undefined) node = header.node;\n    else if (header.lane !== undefined) lane = header.lane;\n    else if (i === 0) node = header;\n    else if (i === 1) lane = header;\n  }\n  if (node !== undefined && lane !== undefined) {\n    return new SyncedResponse(node, lane);\n  }\n};\n\n\nfunction LinkRequest(node, lane, prio) {\n  RequestEnvelope.call(this);\n  this.node = node;\n  this.lane = lane;\n  this.prio = prio || 0.0;\n}\nLinkRequest.prototype = Object.create(RequestEnvelope.prototype);\nLinkRequest.prototype.constructor = LinkRequest;\nObject.defineProperty(LinkRequest.prototype, 'isLinkRequest', {value: true});\nLinkRequest.prototype.encode = function () {\n  var headers = [{node: this.node}, {lane: this.lane}];\n  if (this.prio) headers.push({prio: this.prio});\n  return recon({'@link': headers});\n};\nLinkRequest.decode = function (record) {\n  var node, lane, prio;\n  var headers = recon.head(record);\n  var n = headers && headers.length || 0;\n  for (var i = 0; i < n; i += 1) {\n    var header = headers[i];\n    if (header.node !== undefined) node = header.node;\n    else if (header.lane !== undefined) lane = header.lane;\n    else if (header.prio !== undefined) prio = header.prio;\n    else if (i === 0) node = header;\n    else if (i === 1) lane = header;\n  }\n  if (node !== undefined && lane !== undefined) {\n    return new LinkRequest(node, lane, prio);\n  }\n};\n\n\nfunction LinkedResponse(node, lane, prio) {\n  ResponseEnvelope.call(this);\n  this.node = node;\n  this.lane = lane;\n  this.prio = prio || 0.0;\n}\nLinkedResponse.prototype = Object.create(ResponseEnvelope.prototype);\nLinkedResponse.prototype.constructor = LinkedResponse;\nObject.defineProperty(LinkedResponse.prototype, 'isLinkedResponse', {value: true});\nLinkedResponse.prototype.encode = function () {\n  var headers = [{node: this.node}, {lane: this.lane}];\n  if (this.prio) headers.push({prio: this.prio});\n  return recon({'@linked': headers});\n};\nLinkedResponse.decode = function (record) {\n  var node, lane, prio;\n  var headers = recon.head(record);\n  var n = headers && headers.length || 0;\n  for (var i = 0; i < n; i += 1) {\n    var header = headers[i];\n    if (header.node !== undefined) node = header.node;\n    else if (header.lane !== undefined) lane = header.lane;\n    else if (header.prio !== undefined) prio = header.prio;\n    else if (i === 0) node = header;\n    else if (i === 1) lane = header;\n  }\n  if (node !== undefined && lane !== undefined) {\n    return new LinkedResponse(node, lane, prio);\n  }\n};\n\n\nfunction UnlinkRequest(node, lane) {\n  RequestEnvelope.call(this);\n  this.node = node;\n  this.lane = lane;\n}\nUnlinkRequest.prototype = Object.create(RequestEnvelope.prototype);\nUnlinkRequest.prototype.constructor = UnlinkRequest;\nObject.defineProperty(UnlinkRequest.prototype, 'isUnlinkRequest', {value: true});\nUnlinkRequest.prototype.encode = function () {\n  var headers = [{node: this.node}, {lane: this.lane}];\n  return recon({'@unlink': headers});\n};\nUnlinkRequest.decode = function (record) {\n  var node, lane;\n  var headers = recon.head(record);\n  var n = headers && headers.length || 0;\n  for (var i = 0; i < n; i += 1) {\n    var header = headers[i];\n    if (header.node !== undefined) node = header.node;\n    else if (header.lane !== undefined) lane = header.lane;\n    else if (i === 0) node = header;\n    else if (i === 1) lane = header;\n  }\n  if (node !== undefined && lane !== undefined) {\n    return new UnlinkRequest(node, lane);\n  }\n};\n\n\nfunction UnlinkedResponse(node, lane) {\n  ResponseEnvelope.call(this);\n  this.node = node;\n  this.lane = lane;\n}\nUnlinkedResponse.prototype = Object.create(ResponseEnvelope.prototype);\nUnlinkedResponse.prototype.constructor = UnlinkedResponse;\nObject.defineProperty(UnlinkedResponse.prototype, 'isUnlinkedResponse', {value: true});\nUnlinkedResponse.prototype.encode = function () {\n  var headers = [{node: this.node}, {lane: this.lane}];\n  return recon({'@unlinked': headers});\n};\nUnlinkedResponse.decode = function (record) {\n  var node, lane;\n  var headers = recon.head(record);\n  var n = headers && headers.length || 0;\n  for (var i = 0; i < n; i += 1) {\n    var header = headers[i];\n    if (header.node !== undefined) node = header.node;\n    else if (header.lane !== undefined) lane = header.lane;\n    else if (i === 0) node = header;\n    else if (i === 1) lane = header;\n  }\n  if (node !== undefined && lane !== undefined) {\n    return new UnlinkedResponse(node, lane);\n  }\n};\n\n\nexports.decode = decode;\nexports.encode = encode;\nexports.parse = parse;\nexports.stringify = stringify;\nexports.Envelope = Envelope;\nexports.RequestEnvelope = RequestEnvelope;\nexports.ResponseEnvelope = ResponseEnvelope;\nexports.MessageEnvelope = MessageEnvelope;\nexports.EventMessage = EventMessage;\nexports.CommandMessage = CommandMessage;\nexports.SyncRequest = SyncRequest;\nexports.SyncedResponse = SyncedResponse;\nexports.LinkRequest = LinkRequest;\nexports.LinkedResponse = LinkedResponse;\nexports.UnlinkRequest = UnlinkRequest;\nexports.UnlinkedResponse = UnlinkedResponse;\nexports.config = config;\n\n},{\"./config.json\":3,\"recon-js\":\"recon-js\"}],\"swim-client-js\":[function(require,module,exports){\n(function (global){\n'use strict';\n\nvar config = require('./config.json');\nvar recon = require('recon-js');\nvar proto = require('swim-proto-js');\nvar WebSocket = global.WebSocket || require('websocket').w3cwebsocket;\n\nvar LINK_FAILED = -2;\nvar LINK_BROKEN = -1;\nvar LINK_WANTED = 0;\nvar LINK_ACTIVE = 1;\n\nfunction auth(node, query) {\n  Channel.auth(node, query);\n}\n\nfunction sync(node, lane, handle) {\n  Channel.get(node).sync(node, lane, handle);\n}\n\nfunction link(node, lane, handle) {\n  Channel.get(node).link(node, lane, handle);\n}\n\nfunction unlink(node, lane, handle) {\n  Channel.get(node).unlink(node, lane, handle);\n}\n\nfunction sendEvent(node, lane, body) {\n  Channel.get(node).sendEvent(node, lane, body);\n}\n\nfunction sendCommand(node, lane, body) {\n  Channel.get(node).sendCommand(node, lane, body);\n}\n\nfunction reset() {\n  for (var endpoint in Channel.bridge) {\n    var channel = Channel.bridge[endpoint];\n    channel.sendBuffer = [];\n    channel.unlinkAll();\n    channel.close();\n  }\n  Channel.bridge = {};\n}\n\n\nfunction Channel(node, query) {\n  Channel.bridge[node] = this;\n  this.node = node;\n  this.query = query;\n  this.linkCount = 0;\n  this.linkHandles = {};\n  this.sendBuffer = [];\n  this.reconnectTimeout = null;\n  this.reconnectTime = 250 + Math.round(Math.random() * 750);\n  this.closed = false;\n  this.open();\n}\nChannel.prototype.open = function () {\n  var requestUri = this.node;\n  if (this.query) requestUri = requestUri + '?' + this.query;\n  this.socket = new WebSocket(requestUri);\n  this.socket.onopen = this.onOpen.bind(this);\n  this.socket.onclose = this.onClose.bind(this);\n  this.socket.onmessage = this.onFrame.bind(this);\n  this.socket.onerror = this.onError.bind(this);\n};\nChannel.prototype.close = function () {\n  this.closed = true;\n  this.socket.close();\n};\nChannel.prototype.send = function (envelope) {\n  if (this.socket.readyState !== this.socket.OPEN) this.buffer(envelope);\n  else this.socket.send(proto.stringify(envelope));\n};\nChannel.prototype.buffer = function (envelope) {\n  if (envelope.isSyncRequest || envelope.isLinkRequest || envelope.isUnlinkRequest) return;\n  if (this.sendBuffer.length > config.SEND_BUFFER_SIZE) return; // TODO: Notify\n  this.sendBuffer.push(envelope);\n};\nChannel.prototype.onOpen = function () {\n  clearTimeout(this.reconnectTimeout);\n  this.reconnectTime = 250 + Math.round(Math.random() * 750);\n\n  var envelope;\n  for (var node in this.linkHandles) {\n    var nodeHandles = this.linkHandles[node];\n    for (var lane in nodeHandles) {\n      var laneHandles = nodeHandles[lane];\n      var synced = false;\n      for (var i = 0, n = laneHandles.length; !synced && i < n; i += 1) {\n        var handle = laneHandles[i];\n        var state = handle.__swim_link_state__;\n        synced = synced || state.synced;\n      }\n      if (synced) envelope = new proto.SyncRequest(this.unresolve(node), lane);\n      else envelope = new proto.LinkRequest(this.unresolve(node), lane);\n      this.send(envelope);\n    }\n  }\n\n  while ((envelope = this.sendBuffer.shift())) this.send(envelope);\n};\nChannel.prototype.onClose = function () {\n  if (!this.closed && this.linkCount === 0 && this.sendBuffer.length === 0) {\n    delete Channel.bridge[this.node];\n    return;\n  }\n\n  for (var node in this.linkHandles) {\n    var nodeHandles = this.linkHandles[node];\n    for (var lane in nodeHandles) {\n      var laneHandles = nodeHandles[lane];\n      for (var i = 0, n = laneHandles.length; i < n; i += 1) {\n        var handle = laneHandles[i];\n        var state = handle.__swim_link_state__;\n        if (state.status === LINK_ACTIVE) {\n          if (typeof handle.onBroken === 'function') {\n            handle.onBroken.call(handle, node, lane);\n          }\n          state.status = LINK_BROKEN;\n        }\n      }\n    }\n  }\n\n  if (!this.closed) {\n    this.reconnectTimeout = setTimeout(this.open.bind(this), this.reconnectTime);\n    this.reconnectTime = Math.min(2 * this.reconnectTime, config.MAX_RECONNECT_TIME);\n  }\n};\nChannel.prototype.onError = function () {\n  if (this.socket.readyState === this.socket.OPEN) {\n    this.socket.close();\n  }\n};\nChannel.prototype.onFrame = function (frame) {\n  var payload = frame.data;\n  if (typeof payload === 'string') {\n    var envelope = proto.parse(payload);\n    if (envelope) this.onReceive(envelope);\n  }\n};\nChannel.prototype.initHandle = function (handle, synced) {\n  if (typeof handle === 'function') handle = {\n    onEvent: handle,\n    onCommand: handle\n  };\n  var state = {\n    status: LINK_WANTED,\n    synced: synced\n  };\n  Object.defineProperty(handle, '__swim_link_state__', {value: state, configurable: true});\n  return handle;\n};\nChannel.prototype.registerHandle = function (node, lane, handle) {\n  var unlinked = false;\n  var nodeHandles = this.linkHandles[node];\n  if (nodeHandles === undefined) {\n    nodeHandles = {};\n    this.linkHandles[node] = nodeHandles;\n  }\n  var laneHandles = nodeHandles[lane];\n  if (laneHandles === undefined) {\n    unlinked = true;\n    laneHandles = [];\n    nodeHandles[lane] = laneHandles;\n  }\n  laneHandles.push(handle);\n  return unlinked;\n};\nChannel.prototype.unregisterHandle = function (node, lane, handle) {\n  var nodeHandles = this.linkHandles[node];\n  if (nodeHandles === undefined) return;\n  var laneHandles = nodeHandles[lane];\n  if (laneHandles === undefined) return;\n  var index = -1;\n  if (handle instanceof Function) for (var i = 0, n = laneHandles.length; i < n; i += 1) {\n    if (laneHandles[i].onEvent === handle) { index = i; break; }\n  }\n  else index = laneHandles.indexOf(handle);\n  if (index < 0) return false;\n  laneHandles.splice(index, 1);\n  var unlinked = laneHandles.length === 0;\n  if (unlinked) {\n    delete nodeHandles[lane];\n    if (Object.keys(nodeHandles).length === 0) delete this.linkHandles[node];\n  }\n  return unlinked;\n};\nChannel.prototype.sync = function (node, lane, handle) {\n  handle = this.initHandle(handle, true);\n  var unlinked = this.registerHandle(node, lane, handle);\n  var request = new proto.SyncRequest(this.unresolve(node), lane);\n  this.send(request);\n  if (unlinked) {\n    this.linkCount += 1;\n  }\n};\nChannel.prototype.link = function (node, lane, handle) {\n  handle = this.initHandle(handle, false);\n  var unlinked = this.registerHandle(node, lane, handle);\n  if (unlinked) {\n    var request = new proto.LinkRequest(this.unresolve(node), lane);\n    this.send(request);\n    this.linkCount += 1;\n  }\n  else if (this.socket.readyState === this.socket.OPEN) {\n    var state = handle.__swim_link_state__;\n    state.status = LINK_ACTIVE;\n    if (typeof handle.onLinked === 'function') {\n      handle.onLinked.call(handle, node, lane);\n    }\n  }\n};\nChannel.prototype.unlink = function (node, lane, handle) {\n  var unlinked = this.unregisterHandle(node, lane, handle);\n  if (unlinked) {\n    var request = new proto.UnlinkRequest(this.unresolve(node), lane);\n    this.send(request);\n    this.linkCount -= 1;\n  }\n};\nChannel.prototype.unlinkAll = function () {\n  for (var node in this.linkHandles) {\n    var nodeHandles = this.linkHandles[node];\n    for (var lane in nodeHandles) {\n      var laneHandles = nodeHandles[lane];\n      for (var i = 0, n = laneHandles.length; i < n; i += 1) {\n        var handle = laneHandles[i];\n        var state = handle.__swim_link_state__;\n        if (typeof handle.onFailed === 'function') {\n          handle.onFailed.call(handle, node, lane);\n        }\n        state.status = LINK_FAILED;\n      }\n    }\n  }\n  this.linkCount = 0;\n  this.linkHandles = {};\n};\nChannel.prototype.sendEvent = function (node, lane, body) {\n  var message = new proto.EventMessage(this.unresolve(node), lane, undefined, body);\n  this.send(message);\n};\nChannel.prototype.sendCommand = function (node, lane, body) {\n  var message = new proto.CommandMessage(this.unresolve(node), lane, undefined, body);\n  this.send(message);\n};\nChannel.prototype.onReceive = function (envelope) {\n  if (envelope.isEventMessage) this.onMessage(envelope);\n  else if (envelope.isCommandMessage) this.onMessage(envelope);\n  else if (envelope.isSyncedResponse) this.onSynced(envelope);\n  else if (envelope.isLinkedResponse) this.onLinked(envelope);\n  else if (envelope.isUnlinkedResponse) this.onUnlinked(envelope);\n};\nChannel.prototype.onMessage = function (envelope) {\n  var node = recon.uri.stringify(recon.uri.resolve(this.node, envelope.node));\n  var nodeHandles = this.linkHandles[node];\n  if (nodeHandles === undefined) return;\n\n  var lane = envelope.lane;\n  while (lane) {\n    var laneHandles = nodeHandles[lane];\n    if (laneHandles) for (var i = 0, n = laneHandles.length; i < n; i += 1) {\n      var handle = laneHandles[i];\n      if (envelope.isEventMessage) {\n        if (typeof handle.onEvent === 'function') {\n          handle.onEvent.call(handle, envelope);\n        }\n      }\n      else if (envelope.isCommandMessage) {\n        if (typeof handle.onCommand === 'function') {\n          handle.onCommand.call(handle, envelope);\n        }\n      }\n    }\n    lane = Channel.parentLane(lane);\n  }\n};\nChannel.prototype.onSynced = function (envelope) {\n  var node = recon.uri.stringify(recon.uri.resolve(this.node, envelope.node));\n  var lane = envelope.lane;\n  var nodeHandles = this.linkHandles[node];\n  if (nodeHandles === undefined) return;\n  var laneHandles = nodeHandles[lane];\n  if (laneHandles === undefined) return;\n  for (var i = 0, n = laneHandles.length; i < n; i += 1) {\n    var handle = laneHandles[i];\n    if (typeof handle.onLinked === 'function') {\n      handle.onSynced.call(handle, node, lane);\n    }\n  }\n};\nChannel.prototype.onLinked = function (envelope) {\n  var node = recon.uri.stringify(recon.uri.resolve(this.node, envelope.node));\n  var lane = envelope.lane;\n  var nodeHandles = this.linkHandles[node];\n  if (nodeHandles === undefined) return;\n  var laneHandles = nodeHandles[lane];\n  if (laneHandles === undefined) return;\n  for (var i = 0, n = laneHandles.length; i < n; i += 1) {\n    var handle = laneHandles[i];\n    var state = handle.__swim_link_state__;\n    if (state.status === LINK_BROKEN) {\n      if (typeof handle.onUnbroken === 'function') {\n        handle.onUnbroken.call(handle, node, lane);\n      }\n    }\n    else if (typeof handle.onLinked === 'function') {\n      handle.onLinked.call(handle, node, lane);\n    }\n    state.status = LINK_ACTIVE;\n  }\n};\nChannel.prototype.onUnlinked = function (envelope) {\n  var node = recon.uri.stringify(recon.uri.resolve(this.node, envelope.node));\n  var lane = envelope.lane;\n  var nodeHandles = this.linkHandles[node];\n  if (nodeHandles === undefined) return;\n  var laneHandles = nodeHandles[lane];\n  if (laneHandles === undefined) return;\n  for (var i = 0, n = laneHandles.length; i < n; i += 1) {\n    var handle = laneHandles[i];\n    var state = handle.__swim_link_state__;\n    if (state.status === LINK_ACTIVE) {\n      if (typeof handle.onUnlinked === 'function') {\n        handle.onUnlinked.call(handle, node, lane);\n      }\n      state.status = LINK_WANTED;\n    }\n    else {\n      if (typeof handle.onFailed === 'function') {\n        handle.onFailed.call(handle, node, lane);\n      }\n      state.status = LINK_FAILED;\n    }\n  }\n  delete nodeHandles[lane];\n  if (Object.keys(nodeHandles).length === 0) delete this.linkHandles[node];\n  this.linkCount -= 1;\n};\nChannel.prototype.unresolve = function (node) {\n  return recon.uri.stringify(recon.uri.unresolve(this.node, node));\n};\nChannel.bridge = {};\nChannel.get = function (node) {\n  var endpoint = Channel.endpoint(node);\n  var channel = Channel.bridge[endpoint];\n  if (channel === undefined) channel = new Channel(endpoint);\n  return channel;\n};\nChannel.auth = function (node, query) {\n  var endpoint = Channel.endpoint(node);\n  var channel = Channel.bridge[endpoint];\n  if (channel) {\n    channel.unlinkAll();\n    channel.close();\n    delete Channel.bridge[endpoint];\n  }\n  channel = new Channel(endpoint, query);\n  return channel;\n};\nChannel.endpoint = function (node) {\n  var components = recon.uri.parse(node);\n  var scheme = components.scheme;\n  if (scheme === 'swim') scheme = 'ws';\n  else if (scheme === 'swims') scheme = 'wss';\n  return recon.uri.stringify({\n    scheme: scheme,\n    authority: components.authority\n  });\n};\nChannel.parentLane = function (lane) {\n  var components = recon.uri.parse(lane);\n  var path = components.path;\n  if (components.query && components.fragment) return recon.uri.stringify({\n    path: path,\n    query: components.query\n  });\n  else if (components.query) return recon.uri.stringify({path: path});\n  else if (path.length > 0) {\n    return recon.uri.stringify({path: path.slice(0, path.length - 1)});\n  }\n};\n\n\nexports.auth = auth;\nexports.sync = sync;\nexports.link = link;\nexports.unlink = unlink;\nexports.sendEvent = sendEvent;\nexports.sendCommand = sendCommand;\nexports.reset = reset;\nexports.config = config;\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"./config.json\":1,\"recon-js\":\"recon-js\",\"swim-proto-js\":4,\"websocket\":2}]},{},[])(\"swim-client-js\")\n});\n\n","module.exports={\"version\":\"0.3.0\"}","'use strict';\n\nvar config = require('./config.json');\nvar recon = require('recon-js');\n\nfunction decode(record) {\n  switch (recon.tag(record)) {\n    case '@event': return EventMessage.decode(record);\n    case '@command': return CommandMessage.decode(record);\n    case '@sync': return SyncRequest.decode(record);\n    case '@synced': return SyncedResponse.decode(record);\n    case '@link': return LinkRequest.decode(record);\n    case '@linked': return LinkedResponse.decode(record);\n    case '@unlink': return UnlinkRequest.decode(record);\n    case '@unlinked': return UnlinkedResponse.decode(record);\n  }\n}\n\nfunction encode(envelope) {\n  return envelope.encode();\n}\n\nfunction parse(string) {\n  return decode(recon.parse(string));\n}\n\nfunction stringify(envelope) {\n  return recon.stringify(encode(envelope));\n}\n\n\nfunction Envelope() {}\nObject.defineProperty(Envelope.prototype, 'isRequest', {value: false});\nObject.defineProperty(Envelope.prototype, 'isResponse', {value: false});\nObject.defineProperty(Envelope.prototype, 'isMessage', {value: false});\nObject.defineProperty(Envelope.prototype, 'isEventMessage', {value: false});\nObject.defineProperty(Envelope.prototype, 'isCommandMessage', {value: false});\nObject.defineProperty(Envelope.prototype, 'isSyncRequest', {value: false});\nObject.defineProperty(Envelope.prototype, 'isSyncedResponse', {value: false});\nObject.defineProperty(Envelope.prototype, 'isLinkRequest', {value: false});\nObject.defineProperty(Envelope.prototype, 'isLinkedResponse', {value: false});\nObject.defineProperty(Envelope.prototype, 'isUnlinkRequest', {value: false});\nObject.defineProperty(Envelope.prototype, 'isUnlinkedResponse', {value: false});\n\n\nfunction RequestEnvelope() {\n  Envelope.call(this);\n}\nRequestEnvelope.prototype = Object.create(Envelope.prototype);\nRequestEnvelope.prototype.constructor = RequestEnvelope;\nObject.defineProperty(RequestEnvelope.prototype, 'isRequest', {value: true});\n\n\nfunction ResponseEnvelope() {\n  Envelope.call(this);\n}\nResponseEnvelope.prototype = Object.create(Envelope.prototype);\nResponseEnvelope.prototype.constructor = ResponseEnvelope;\nObject.defineProperty(RequestEnvelope.prototype, 'isResponse', {value: true});\n\n\nfunction MessageEnvelope() {\n  Envelope.call(this);\n}\nMessageEnvelope.prototype = Object.create(Envelope.prototype);\nMessageEnvelope.prototype.constructor = MessageEnvelope;\nObject.defineProperty(RequestEnvelope.prototype, 'isMessage', {value: true});\n\n\nfunction EventMessage(node, lane, via, body) {\n  MessageEnvelope.call(this);\n  this.node = node;\n  this.lane = lane;\n  this.via = via;\n  this.body = body;\n}\nEventMessage.prototype = Object.create(MessageEnvelope.prototype);\nEventMessage.prototype.constructor = EventMessage;\nObject.defineProperty(EventMessage.prototype, 'isEventMessage', {value: true});\nEventMessage.prototype.encode = function () {\n  var headers = [{node: this.node}, {lane: this.lane}];\n  if (this.via) headers.push({via: this.via});\n  return recon.concat({'@event': headers}, this.body);\n};\nEventMessage.decode = function (record) {\n  var node, lane, via;\n  var body = recon.tail(record);\n  var headers = recon.head(record);\n  var n = headers && headers.length || 0;\n  for (var i = 0; i < n; i += 1) {\n    var header = headers[i];\n    if (header.node !== undefined) node = header.node;\n    else if (header.lane !== undefined) lane = header.lane;\n    else if (header.via !== undefined) via = header.via;\n    else if (i === 0) node = header;\n    else if (i === 1) lane = header;\n    else if (i === 2) via = header;\n  }\n  if (node !== undefined && lane !== undefined) {\n    return new EventMessage(node, lane, via, body);\n  }\n};\n\n\nfunction CommandMessage(node, lane, via, body) {\n  MessageEnvelope.call(this);\n  this.node = node;\n  this.lane = lane;\n  this.via = via;\n  this.body = body;\n}\nCommandMessage.prototype = Object.create(MessageEnvelope.prototype);\nCommandMessage.prototype.constructor = CommandMessage;\nObject.defineProperty(CommandMessage.prototype, 'isCommandMessage', {value: true});\nCommandMessage.prototype.encode = function () {\n  var headers = [{node: this.node}, {lane: this.lane}];\n  if (this.via) headers.push({via: this.via});\n  return recon.concat({'@command': headers}, this.body);\n};\nCommandMessage.decode = function (record) {\n  var node, lane, via;\n  var body = recon.tail(record);\n  var headers = recon.head(record);\n  var n = headers && headers.length || 0;\n  for (var i = 0; i < n; i += 1) {\n    var header = headers[i];\n    if (header.node !== undefined) node = header.node;\n    else if (header.lane !== undefined) lane = header.lane;\n    else if (header.via !== undefined) via = header.via;\n    else if (i === 0) node = header;\n    else if (i === 1) lane = header;\n    else if (i === 2) via = header;\n  }\n  if (node !== undefined && lane !== undefined) {\n    return new CommandMessage(node, lane, via, body);\n  }\n};\n\n\nfunction SyncRequest(node, lane, prio) {\n  RequestEnvelope.call(this);\n  this.node = node;\n  this.lane = lane;\n  this.prio = prio || 0.0;\n}\nSyncRequest.prototype = Object.create(RequestEnvelope.prototype);\nSyncRequest.prototype.constructor = SyncRequest;\nObject.defineProperty(SyncRequest.prototype, 'isSyncRequest', {value: true});\nSyncRequest.prototype.encode = function () {\n  var headers = [{node: this.node}, {lane: this.lane}];\n  if (this.prio) headers.push({prio: this.prio});\n  return recon({'@sync': headers});\n};\nSyncRequest.decode = function (record) {\n  var node, lane, prio;\n  var headers = recon.head(record);\n  var n = headers && headers.length || 0;\n  for (var i = 0; i < n; i += 1) {\n    var header = headers[i];\n    if (header.node !== undefined) node = header.node;\n    else if (header.lane !== undefined) lane = header.lane;\n    else if (header.prio !== undefined) prio = header.prio;\n    else if (i === 0) node = header;\n    else if (i === 1) lane = header;\n  }\n  if (node !== undefined && lane !== undefined) {\n    return new SyncRequest(node, lane, prio);\n  }\n};\n\n\nfunction SyncedResponse(node, lane) {\n  ResponseEnvelope.call(this);\n  this.node = node;\n  this.lane = lane;\n}\nSyncedResponse.prototype = Object.create(ResponseEnvelope.prototype);\nSyncedResponse.prototype.constructor = SyncedResponse;\nObject.defineProperty(SyncedResponse.prototype, 'isSyncedResponse', {value: true});\nSyncedResponse.prototype.encode = function () {\n  var headers = [{node: this.node}, {lane: this.lane}];\n  return recon({'@synced': headers});\n};\nSyncedResponse.decode = function (record) {\n  var node, lane;\n  var headers = recon.head(record);\n  var n = headers && headers.length || 0;\n  for (var i = 0; i < n; i += 1) {\n    var header = headers[i];\n    if (header.node !== undefined) node = header.node;\n    else if (header.lane !== undefined) lane = header.lane;\n    else if (i === 0) node = header;\n    else if (i === 1) lane = header;\n  }\n  if (node !== undefined && lane !== undefined) {\n    return new SyncedResponse(node, lane);\n  }\n};\n\n\nfunction LinkRequest(node, lane, prio) {\n  RequestEnvelope.call(this);\n  this.node = node;\n  this.lane = lane;\n  this.prio = prio || 0.0;\n}\nLinkRequest.prototype = Object.create(RequestEnvelope.prototype);\nLinkRequest.prototype.constructor = LinkRequest;\nObject.defineProperty(LinkRequest.prototype, 'isLinkRequest', {value: true});\nLinkRequest.prototype.encode = function () {\n  var headers = [{node: this.node}, {lane: this.lane}];\n  if (this.prio) headers.push({prio: this.prio});\n  return recon({'@link': headers});\n};\nLinkRequest.decode = function (record) {\n  var node, lane, prio;\n  var headers = recon.head(record);\n  var n = headers && headers.length || 0;\n  for (var i = 0; i < n; i += 1) {\n    var header = headers[i];\n    if (header.node !== undefined) node = header.node;\n    else if (header.lane !== undefined) lane = header.lane;\n    else if (header.prio !== undefined) prio = header.prio;\n    else if (i === 0) node = header;\n    else if (i === 1) lane = header;\n  }\n  if (node !== undefined && lane !== undefined) {\n    return new LinkRequest(node, lane, prio);\n  }\n};\n\n\nfunction LinkedResponse(node, lane, prio) {\n  ResponseEnvelope.call(this);\n  this.node = node;\n  this.lane = lane;\n  this.prio = prio || 0.0;\n}\nLinkedResponse.prototype = Object.create(ResponseEnvelope.prototype);\nLinkedResponse.prototype.constructor = LinkedResponse;\nObject.defineProperty(LinkedResponse.prototype, 'isLinkedResponse', {value: true});\nLinkedResponse.prototype.encode = function () {\n  var headers = [{node: this.node}, {lane: this.lane}];\n  if (this.prio) headers.push({prio: this.prio});\n  return recon({'@linked': headers});\n};\nLinkedResponse.decode = function (record) {\n  var node, lane, prio;\n  var headers = recon.head(record);\n  var n = headers && headers.length || 0;\n  for (var i = 0; i < n; i += 1) {\n    var header = headers[i];\n    if (header.node !== undefined) node = header.node;\n    else if (header.lane !== undefined) lane = header.lane;\n    else if (header.prio !== undefined) prio = header.prio;\n    else if (i === 0) node = header;\n    else if (i === 1) lane = header;\n  }\n  if (node !== undefined && lane !== undefined) {\n    return new LinkedResponse(node, lane, prio);\n  }\n};\n\n\nfunction UnlinkRequest(node, lane) {\n  RequestEnvelope.call(this);\n  this.node = node;\n  this.lane = lane;\n}\nUnlinkRequest.prototype = Object.create(RequestEnvelope.prototype);\nUnlinkRequest.prototype.constructor = UnlinkRequest;\nObject.defineProperty(UnlinkRequest.prototype, 'isUnlinkRequest', {value: true});\nUnlinkRequest.prototype.encode = function () {\n  var headers = [{node: this.node}, {lane: this.lane}];\n  return recon({'@unlink': headers});\n};\nUnlinkRequest.decode = function (record) {\n  var node, lane;\n  var headers = recon.head(record);\n  var n = headers && headers.length || 0;\n  for (var i = 0; i < n; i += 1) {\n    var header = headers[i];\n    if (header.node !== undefined) node = header.node;\n    else if (header.lane !== undefined) lane = header.lane;\n    else if (i === 0) node = header;\n    else if (i === 1) lane = header;\n  }\n  if (node !== undefined && lane !== undefined) {\n    return new UnlinkRequest(node, lane);\n  }\n};\n\n\nfunction UnlinkedResponse(node, lane) {\n  ResponseEnvelope.call(this);\n  this.node = node;\n  this.lane = lane;\n}\nUnlinkedResponse.prototype = Object.create(ResponseEnvelope.prototype);\nUnlinkedResponse.prototype.constructor = UnlinkedResponse;\nObject.defineProperty(UnlinkedResponse.prototype, 'isUnlinkedResponse', {value: true});\nUnlinkedResponse.prototype.encode = function () {\n  var headers = [{node: this.node}, {lane: this.lane}];\n  return recon({'@unlinked': headers});\n};\nUnlinkedResponse.decode = function (record) {\n  var node, lane;\n  var headers = recon.head(record);\n  var n = headers && headers.length || 0;\n  for (var i = 0; i < n; i += 1) {\n    var header = headers[i];\n    if (header.node !== undefined) node = header.node;\n    else if (header.lane !== undefined) lane = header.lane;\n    else if (i === 0) node = header;\n    else if (i === 1) lane = header;\n  }\n  if (node !== undefined && lane !== undefined) {\n    return new UnlinkedResponse(node, lane);\n  }\n};\n\n\nexports.decode = decode;\nexports.encode = encode;\nexports.parse = parse;\nexports.stringify = stringify;\nexports.Envelope = Envelope;\nexports.RequestEnvelope = RequestEnvelope;\nexports.ResponseEnvelope = ResponseEnvelope;\nexports.MessageEnvelope = MessageEnvelope;\nexports.EventMessage = EventMessage;\nexports.CommandMessage = CommandMessage;\nexports.SyncRequest = SyncRequest;\nexports.SyncedResponse = SyncedResponse;\nexports.LinkRequest = LinkRequest;\nexports.LinkedResponse = LinkedResponse;\nexports.UnlinkRequest = UnlinkRequest;\nexports.UnlinkedResponse = UnlinkedResponse;\nexports.config = config;\n","'use strict';\n\nvar config = require('./config.json');\nvar recon = require('recon-js');\nvar proto = require('swim-proto-js');\nvar WebSocket = global.WebSocket || require('websocket').w3cwebsocket;\n\nvar LINK_FAILED = -2;\nvar LINK_BROKEN = -1;\nvar LINK_WANTED = 0;\nvar LINK_ACTIVE = 1;\n\nfunction auth(node, query) {\n  Channel.auth(node, query);\n}\n\nfunction sync(node, lane, handle) {\n  Channel.get(node).sync(node, lane, handle);\n}\n\nfunction link(node, lane, handle) {\n  Channel.get(node).link(node, lane, handle);\n}\n\nfunction unlink(node, lane, handle) {\n  Channel.get(node).unlink(node, lane, handle);\n}\n\nfunction sendEvent(node, lane, body) {\n  Channel.get(node).sendEvent(node, lane, body);\n}\n\nfunction sendCommand(node, lane, body) {\n  Channel.get(node).sendCommand(node, lane, body);\n}\n\nfunction reset() {\n  for (var endpoint in Channel.bridge) {\n    var channel = Channel.bridge[endpoint];\n    channel.sendBuffer = [];\n    channel.unlinkAll();\n    channel.close();\n  }\n  Channel.bridge = {};\n}\n\n\nfunction Channel(node, query) {\n  Channel.bridge[node] = this;\n  this.node = node;\n  this.query = query;\n  this.linkCount = 0;\n  this.linkHandles = {};\n  this.sendBuffer = [];\n  this.reconnectTimeout = null;\n  this.reconnectTime = 250 + Math.round(Math.random() * 750);\n  this.closed = false;\n  this.open();\n}\nChannel.prototype.open = function () {\n  var requestUri = this.node;\n  if (this.query) requestUri = requestUri + '?' + this.query;\n  this.socket = new WebSocket(requestUri);\n  this.socket.onopen = this.onOpen.bind(this);\n  this.socket.onclose = this.onClose.bind(this);\n  this.socket.onmessage = this.onFrame.bind(this);\n  this.socket.onerror = this.onError.bind(this);\n};\nChannel.prototype.close = function () {\n  this.closed = true;\n  this.socket.close();\n};\nChannel.prototype.send = function (envelope) {\n  if (this.socket.readyState !== this.socket.OPEN) this.buffer(envelope);\n  else this.socket.send(proto.stringify(envelope));\n};\nChannel.prototype.buffer = function (envelope) {\n  if (envelope.isSyncRequest || envelope.isLinkRequest || envelope.isUnlinkRequest) return;\n  if (this.sendBuffer.length > config.SEND_BUFFER_SIZE) return; // TODO: Notify\n  this.sendBuffer.push(envelope);\n};\nChannel.prototype.onOpen = function () {\n  clearTimeout(this.reconnectTimeout);\n  this.reconnectTime = 250 + Math.round(Math.random() * 750);\n\n  var envelope;\n  for (var node in this.linkHandles) {\n    var nodeHandles = this.linkHandles[node];\n    for (var lane in nodeHandles) {\n      var laneHandles = nodeHandles[lane];\n      var synced = false;\n      for (var i = 0, n = laneHandles.length; !synced && i < n; i += 1) {\n        var handle = laneHandles[i];\n        var state = handle.__swim_link_state__;\n        synced = synced || state.synced;\n      }\n      if (synced) envelope = new proto.SyncRequest(this.unresolve(node), lane);\n      else envelope = new proto.LinkRequest(this.unresolve(node), lane);\n      this.send(envelope);\n    }\n  }\n\n  while ((envelope = this.sendBuffer.shift())) this.send(envelope);\n};\nChannel.prototype.onClose = function () {\n  if (!this.closed && this.linkCount === 0 && this.sendBuffer.length === 0) {\n    delete Channel.bridge[this.node];\n    return;\n  }\n\n  for (var node in this.linkHandles) {\n    var nodeHandles = this.linkHandles[node];\n    for (var lane in nodeHandles) {\n      var laneHandles = nodeHandles[lane];\n      for (var i = 0, n = laneHandles.length; i < n; i += 1) {\n        var handle = laneHandles[i];\n        var state = handle.__swim_link_state__;\n        if (state.status === LINK_ACTIVE) {\n          if (typeof handle.onBroken === 'function') {\n            handle.onBroken.call(handle, node, lane);\n          }\n          state.status = LINK_BROKEN;\n        }\n      }\n    }\n  }\n\n  if (!this.closed) {\n    this.reconnectTimeout = setTimeout(this.open.bind(this), this.reconnectTime);\n    this.reconnectTime = Math.min(2 * this.reconnectTime, config.MAX_RECONNECT_TIME);\n  }\n};\nChannel.prototype.onError = function () {\n  if (this.socket.readyState === this.socket.OPEN) {\n    this.socket.close();\n  }\n};\nChannel.prototype.onFrame = function (frame) {\n  var payload = frame.data;\n  if (typeof payload === 'string') {\n    var envelope = proto.parse(payload);\n    if (envelope) this.onReceive(envelope);\n  }\n};\nChannel.prototype.initHandle = function (handle, synced) {\n  if (typeof handle === 'function') handle = {\n    onEvent: handle,\n    onCommand: handle\n  };\n  var state = {\n    status: LINK_WANTED,\n    synced: synced\n  };\n  Object.defineProperty(handle, '__swim_link_state__', {value: state, configurable: true});\n  return handle;\n};\nChannel.prototype.registerHandle = function (node, lane, handle) {\n  var unlinked = false;\n  var nodeHandles = this.linkHandles[node];\n  if (nodeHandles === undefined) {\n    nodeHandles = {};\n    this.linkHandles[node] = nodeHandles;\n  }\n  var laneHandles = nodeHandles[lane];\n  if (laneHandles === undefined) {\n    unlinked = true;\n    laneHandles = [];\n    nodeHandles[lane] = laneHandles;\n  }\n  laneHandles.push(handle);\n  return unlinked;\n};\nChannel.prototype.unregisterHandle = function (node, lane, handle) {\n  var nodeHandles = this.linkHandles[node];\n  if (nodeHandles === undefined) return;\n  var laneHandles = nodeHandles[lane];\n  if (laneHandles === undefined) return;\n  var index = -1;\n  if (handle instanceof Function) for (var i = 0, n = laneHandles.length; i < n; i += 1) {\n    if (laneHandles[i].onEvent === handle) { index = i; break; }\n  }\n  else index = laneHandles.indexOf(handle);\n  if (index < 0) return false;\n  laneHandles.splice(index, 1);\n  var unlinked = laneHandles.length === 0;\n  if (unlinked) {\n    delete nodeHandles[lane];\n    if (Object.keys(nodeHandles).length === 0) delete this.linkHandles[node];\n  }\n  return unlinked;\n};\nChannel.prototype.sync = function (node, lane, handle) {\n  handle = this.initHandle(handle, true);\n  var unlinked = this.registerHandle(node, lane, handle);\n  var request = new proto.SyncRequest(this.unresolve(node), lane);\n  this.send(request);\n  if (unlinked) {\n    this.linkCount += 1;\n  }\n};\nChannel.prototype.link = function (node, lane, handle) {\n  handle = this.initHandle(handle, false);\n  var unlinked = this.registerHandle(node, lane, handle);\n  if (unlinked) {\n    var request = new proto.LinkRequest(this.unresolve(node), lane);\n    this.send(request);\n    this.linkCount += 1;\n  }\n  else if (this.socket.readyState === this.socket.OPEN) {\n    var state = handle.__swim_link_state__;\n    state.status = LINK_ACTIVE;\n    if (typeof handle.onLinked === 'function') {\n      handle.onLinked.call(handle, node, lane);\n    }\n  }\n};\nChannel.prototype.unlink = function (node, lane, handle) {\n  var unlinked = this.unregisterHandle(node, lane, handle);\n  if (unlinked) {\n    var request = new proto.UnlinkRequest(this.unresolve(node), lane);\n    this.send(request);\n    this.linkCount -= 1;\n  }\n};\nChannel.prototype.unlinkAll = function () {\n  for (var node in this.linkHandles) {\n    var nodeHandles = this.linkHandles[node];\n    for (var lane in nodeHandles) {\n      var laneHandles = nodeHandles[lane];\n      for (var i = 0, n = laneHandles.length; i < n; i += 1) {\n        var handle = laneHandles[i];\n        var state = handle.__swim_link_state__;\n        if (typeof handle.onFailed === 'function') {\n          handle.onFailed.call(handle, node, lane);\n        }\n        state.status = LINK_FAILED;\n      }\n    }\n  }\n  this.linkCount = 0;\n  this.linkHandles = {};\n};\nChannel.prototype.sendEvent = function (node, lane, body) {\n  var message = new proto.EventMessage(this.unresolve(node), lane, undefined, body);\n  this.send(message);\n};\nChannel.prototype.sendCommand = function (node, lane, body) {\n  var message = new proto.CommandMessage(this.unresolve(node), lane, undefined, body);\n  this.send(message);\n};\nChannel.prototype.onReceive = function (envelope) {\n  if (envelope.isEventMessage) this.onMessage(envelope);\n  else if (envelope.isCommandMessage) this.onMessage(envelope);\n  else if (envelope.isSyncedResponse) this.onSynced(envelope);\n  else if (envelope.isLinkedResponse) this.onLinked(envelope);\n  else if (envelope.isUnlinkedResponse) this.onUnlinked(envelope);\n};\nChannel.prototype.onMessage = function (envelope) {\n  var node = recon.uri.stringify(recon.uri.resolve(this.node, envelope.node));\n  var nodeHandles = this.linkHandles[node];\n  if (nodeHandles === undefined) return;\n\n  var lane = envelope.lane;\n  while (lane) {\n    var laneHandles = nodeHandles[lane];\n    if (laneHandles) for (var i = 0, n = laneHandles.length; i < n; i += 1) {\n      var handle = laneHandles[i];\n      if (envelope.isEventMessage) {\n        if (typeof handle.onEvent === 'function') {\n          handle.onEvent.call(handle, envelope);\n        }\n      }\n      else if (envelope.isCommandMessage) {\n        if (typeof handle.onCommand === 'function') {\n          handle.onCommand.call(handle, envelope);\n        }\n      }\n    }\n    lane = Channel.parentLane(lane);\n  }\n};\nChannel.prototype.onSynced = function (envelope) {\n  var node = recon.uri.stringify(recon.uri.resolve(this.node, envelope.node));\n  var lane = envelope.lane;\n  var nodeHandles = this.linkHandles[node];\n  if (nodeHandles === undefined) return;\n  var laneHandles = nodeHandles[lane];\n  if (laneHandles === undefined) return;\n  for (var i = 0, n = laneHandles.length; i < n; i += 1) {\n    var handle = laneHandles[i];\n    if (typeof handle.onLinked === 'function') {\n      handle.onSynced.call(handle, node, lane);\n    }\n  }\n};\nChannel.prototype.onLinked = function (envelope) {\n  var node = recon.uri.stringify(recon.uri.resolve(this.node, envelope.node));\n  var lane = envelope.lane;\n  var nodeHandles = this.linkHandles[node];\n  if (nodeHandles === undefined) return;\n  var laneHandles = nodeHandles[lane];\n  if (laneHandles === undefined) return;\n  for (var i = 0, n = laneHandles.length; i < n; i += 1) {\n    var handle = laneHandles[i];\n    var state = handle.__swim_link_state__;\n    if (state.status === LINK_BROKEN) {\n      if (typeof handle.onUnbroken === 'function') {\n        handle.onUnbroken.call(handle, node, lane);\n      }\n    }\n    else if (typeof handle.onLinked === 'function') {\n      handle.onLinked.call(handle, node, lane);\n    }\n    state.status = LINK_ACTIVE;\n  }\n};\nChannel.prototype.onUnlinked = function (envelope) {\n  var node = recon.uri.stringify(recon.uri.resolve(this.node, envelope.node));\n  var lane = envelope.lane;\n  var nodeHandles = this.linkHandles[node];\n  if (nodeHandles === undefined) return;\n  var laneHandles = nodeHandles[lane];\n  if (laneHandles === undefined) return;\n  for (var i = 0, n = laneHandles.length; i < n; i += 1) {\n    var handle = laneHandles[i];\n    var state = handle.__swim_link_state__;\n    if (state.status === LINK_ACTIVE) {\n      if (typeof handle.onUnlinked === 'function') {\n        handle.onUnlinked.call(handle, node, lane);\n      }\n      state.status = LINK_WANTED;\n    }\n    else {\n      if (typeof handle.onFailed === 'function') {\n        handle.onFailed.call(handle, node, lane);\n      }\n      state.status = LINK_FAILED;\n    }\n  }\n  delete nodeHandles[lane];\n  if (Object.keys(nodeHandles).length === 0) delete this.linkHandles[node];\n  this.linkCount -= 1;\n};\nChannel.prototype.unresolve = function (node) {\n  return recon.uri.stringify(recon.uri.unresolve(this.node, node));\n};\nChannel.bridge = {};\nChannel.get = function (node) {\n  var endpoint = Channel.endpoint(node);\n  var channel = Channel.bridge[endpoint];\n  if (channel === undefined) channel = new Channel(endpoint);\n  return channel;\n};\nChannel.auth = function (node, query) {\n  var endpoint = Channel.endpoint(node);\n  var channel = Channel.bridge[endpoint];\n  if (channel) {\n    channel.unlinkAll();\n    channel.close();\n    delete Channel.bridge[endpoint];\n  }\n  channel = new Channel(endpoint, query);\n  return channel;\n};\nChannel.endpoint = function (node) {\n  var components = recon.uri.parse(node);\n  var scheme = components.scheme;\n  if (scheme === 'swim') scheme = 'ws';\n  else if (scheme === 'swims') scheme = 'wss';\n  return recon.uri.stringify({\n    scheme: scheme,\n    authority: components.authority\n  });\n};\nChannel.parentLane = function (lane) {\n  var components = recon.uri.parse(lane);\n  var path = components.path;\n  if (components.query && components.fragment) return recon.uri.stringify({\n    path: path,\n    query: components.query\n  });\n  else if (components.query) return recon.uri.stringify({path: path});\n  else if (path.length > 0) {\n    return recon.uri.stringify({path: path.slice(0, path.length - 1)});\n  }\n};\n\n\nexports.auth = auth;\nexports.sync = sync;\nexports.link = link;\nexports.unlink = unlink;\nexports.sendEvent = sendEvent;\nexports.sendCommand = sendCommand;\nexports.reset = reset;\nexports.config = config;\n"],"sourceRoot":"/source/"}